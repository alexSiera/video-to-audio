 так короче это такое что вообще такое, значит? Мы скриним людей, особенно тех, в которых заканчивается проекция. Ну, я для себя это себе объясняю, как надо понимать, короче, у кого есть какие-то, короче, проблемы с говорением. И в кого мы как бы веруем, что он пройдет, типа, на следующий сценарий. В кого мы, типа, не веруем. Вот. В конечном итоге строится сейчас пока это около 40 экспериментальная как бы история строить пока будет как сначала наверное я позадаю общий всякие разные синические вопросы дальше тут кто-нибудь изнаюет подхватит и позапа задают вопросы уже какие-то около монархи по проектам может быть покажет то есть собственный в конечном итоге если там будет много проблем я тебе все весь этот список передам того что как бы по-хорошему повторить какие-то еще рекомендации и если требуется следующий раз еще раз соберемся чтобы это все типа прощать тебя насколько я знаю в целом хорошо проходишь на теномельная я бы наверное еще раз хотел просто пообщаться в этом плане да и короче это не по крайней мере сейчас это не обучение к собеседованиям, это, поэтому, если где-то, как бы, будут какие-то проблемы, по крайней мере, вот, в технической части, я просто буду говорить, типа, там, да-нет, как бы, там, может быть, пару слов, комментариев, и сразу перехватываю следующим вопросом. Мы не даем время, чтобы это не читал лекции. Окей. Так, давай тогда с самого начала такого начнем. Можешь мне сказать принцип ОВП? Наследование полиморфизма и наследование полиморфизма и инкапсуляция. Инкапсуляция, наследование полиморфизма. Ну, практически по предложению. Инкапсуляция – сокрытие деталей. То есть мы сокрываем детали, собственно говоря, реализации за какими-то классами, например. Полиморфизм – это значит, что мы можем один и тот же класс использовать по-разному. То бишь у него несколько форм использования. Ну, то есть полиморфизм это значит, что мы можем один и тот же класс использовать по-разному. То бишь у него несколько форм использования, ну то есть полиморф. Несколько форм в разных условиях по-разному можем использовать. В основном при помощи event-delegation так называемого. Это не всем корректно на самом деле. Как в TypeScript достигается полиморфизм? В TypeScript полиморфизм... Ну, за счет имплементации интерфейсов получается различных. Потому что имплементируешь интерфейсы различные. И тем самым, можешь один и тот же класс. Ну, то есть ты один базовый класс расширяешь другими классами и соответственно он у тебя по-разному может использоваться в разных условиях. Там не совсем про класс, но окей, ладно. А наследование что такое? Наследование это когда ты можешь у тебя есть некий прототип, ну как в JS получается прототипное наследование и на основе него ты можешь делать так называемых потомков или children, то есть ты можешь на основе какого-то одного объекта создавать другие. Они наследуют все свойства родительского класса. Окей. Можешь мне рассказать, что такое Solid? Solid принципы... Сейчас, извини, пожалуйста, опять перебью. Мне, короче, в каком формате надо? Мне надо, наверное, чтобы ты каждую букву, например, а не все сразу. OpenClosed открытый для расширения, закрытый для изменения. I, это у нас L, да. Lisk of Substitution, то, что у нас дочерние классы не должны ломать логику родительских классов, то есть они должны корректно имплементировать все то, что было в родительском классе, не ломать логику. Так, и это у нас interface segregation, то есть у нас мы не должны зависеть на те интерфейсы, которые мы не используем, собственно говоря. То есть нужноеть на те интерфейсы, которые мы не используем. То есть нужно будет лишних интерфейсов. И D, dependency inversion, инверсия зависимости. То, что мы должны завязываться на абстракции, а не на конкретную реализацию. И, соответственно, в конкретно применить на криакту, это, например, рендер пропс. То есть мы как бы снаружи задаем да да да да да да вот пробкинг лоус побольше можешь сказать пример как он приведет к нуууууу и хорошо да к примеру к примеру допустим у нас у нас допустим один класс, например, какой-нибудь заказ, и его можно печатать, его можно посылать по e-mail, его можно посылать по смс и так далее. Если это все писать в одном классе, то будет очень плохо, потому что придется все время этот класс модифицировать. Проще сделать, соответственно, много разных классов, которые будут имплементировать какую-то конкретную часть. Ты мне больше про синглориспенсибилицы рассказываешь. Ну, они там, по сути, взаимосвязаны. И, соответственно, мы... Если нам нужно имплементировать что-то новое, мы стараемся Добавлять новый класс, а не Модифицировать уже существующий Вот так Мы не в этом классе пишем Мы создаем какой-то новый Новый объект Там, принт сервис Там еще что-нибудь Окей Так, можешь мне пяток паттернов Gang of War назвать ОП-шных? Какие вот часто встречаются? Какие работаешь? Пяток паттернов... Так. Что за паттерны? ОП-шные паттерны. Про Gang ofор я сказал, потому что есть книжка типа «Банда четырех», вот они там все описаны. Как они там? Эти порождающие? Не-не-не, вот не именно название. Прокси, фабрика, что там еще? Прокси, фабрика, там еще Proxy, Fabrica, у нас там еще есть этот как, когда все объединяется в одно. Фасад. Давай так, символтон. В чем? Да. То, что мы все в одном месте описываем. Вернее, не так. У нас один инстанс чего-то, и его не может быть больше, чем один. Как он в JSON достигается? Как его в JSON реализовать? Насколько я знаю, в классе делается некая переменная, туда устанавливается instance класса И потом, когда мы хотим создать еще один такой instance, то у нас не получается сделать Это классическая штука Ну окей, нормально Наблюдатель это когда мы к как что-то с этим сделать. Хорошо. Что такое сложность алгоритма? Сложность алгоритма это OATN и соответственно это мера того, насколько эффективным является алгоритм, насколько быстро он выполнится, за какое количество операций. Давай так, можешь мне назвать сложность линейного поиска? Вот N. А бинарного знаешь? N квадрат, если я правильно помню. Что быстрее, N или N квадрат, если я правильно помню. Что быстрее, n, uatn или uatn квадрат? n. Лучше линейный. А бинарный поиск, да, что такое? Бинарный, бинарный... А, логарифм. Логарифм. Да, логарифм. Он делит пополам все время. Угу. Немножко. Так. Немножко функционально программировать. делят пополам все время. Так, немножко по функционально программированию хочу еще поговорить. Что такое функция выше порядка? Функция выше порядка. Хок — это обертка над какой-либо функцией, которая добавляет какой-либо функционал к этой функции. Например, раньше подключался Redux таким образом. Погоди, что такое Hock? Функция выше порядка. Как он расшифровывается? High Order Component. А что функция там делаешь? Ну, он оборачивает другой компонент. Немножко не так выразился. Это компонент, который оборачивает другой компонент. Если что, я меня сейчас давлю, ты меня тоже сужай. Еще раз, можешь мне определение функции в общем порядка дать? Вот это функция, которая оборачивает другую функцию и что-то добавляет в нее. Не совсем по-корректу. А чистая функция что такая? Чистая функция, которая выдает один и тот же результат. Ее результат зависит от того, что в нее залетает, от пропсов так называемых. А чего там нет знаков? Мутации значений. Я про сайд-эффекты. А иммутабельность что такое? Иммутабельность это когда мы не мутируем какие-либо данные, а делаем их копию. На примере Redux того же самого. эмутируем какие-либо данные, делаем их копию. На примере Redux. На чем просто они будут работать. Тогда по вебу теперь. Что такое HTTP? В чем его отличается от HTTPS? HTTP – протокол общения с браузером. Собственно говоря, при помощи него идет запрос на сервер. Отличается он от HTTPS тем, что HTTPS является шифрованным по умолчанию. Соответственно, на HTTP нет шифрования в HTTP протоколе. И они на разных портах работают. А какую проблему HTTPS от HTTP решает сейчас? Уязвимость короче. Ну, насколько я знаю, смысл в том, что ты можешь этот HTTP запрос как угодно прочитать, а в случае с HTTPS он шифрует этот запрос. Это основное отличие. А в случае с HTPY он шифрует его, этот запрос. Это основное отличие. Как пакет HTPY, HTPY, что в нем содержится, чтобы он доставился от точки A до точки B? Заголовок, тело. В заголовках что обычно лежит? В заголовках флаги обычно лежат различного рода. Например, авторизация. Их достаточно много этих флагов. Ты про хедер? Ну да. Хедер. Хедер это заголовки. Хорошо, хедер есть. Что еще? Хедер, бадди. Это тел Хорошо, что еще есть. Что еще? Хедер, body, это тело. Тело есть. Что еще? Мы пытаемся доставить информацию сюда. Что нам надо, чтобы доставить? Ну, URL, наверное. Ну, да, URL. Вот. И чтобы здесь в нужный, если проразговариваем, хендер. А, метод. Да. Основные методы, знаешь, какие? Если мы проразвиваем метод. Основные методы знаешь какие? Get, Post, Put, Delete. Четыре основных метода. Что из них для обновления? Патч. А Put? Для чего? Патч и Put. Их два. Знаешь, в чем разница между ними? Ну такая тоже,арноминальная. Ну, патч больше для таких, я так понимаю, небольших модификаций. Типа, там, значение, а путь больше для... Все так, да. Какую проблему CORS, короче, решает? Какую ее выязвимость? CORS решает кросс-доменные запросы, соответственно, что ты не можешь с другого домена выполнить запрос. Если у тебя не разрешен политика безопасности, то это запрос. Ну, собственно, по названию курс. Cross-Origin Domain Request. Хорошо. Можешь привести, как это типа работает? Как проверить, что на домене, скажем, в Яндекс.ру стоит курс? Потому что ты не можешь запросы посылать с другого домена на этот домен, получается. Хорошо. Выдается ошибка в браузере. А XSS что такое? XSS уязвимость, при которой подменяется как раз вот это, что связано с корсом. Можешь мне привести пример, как можно короче данные, скажем, украсить через XSS? Насколько я помню, там что-то связано вроде бы или с этим с куками или что-то. Нет, к сожалению. Это про юзер-дженерated контент чаще всего. Это про то, что ты можешь в базу засунуть... Мал короче ход, и он на другого клиента вспомнил. у меня есть вопрос, что такое с клиентским рендеринг и static site generation. Клиентский, когда мы рендеринг, когда мы на стороне сервера рисуем. Есть еще гибридный рендеринг, когда мы часть рисуем на сервере, часть рисуем на клиенте. Ну, то бишь, оно там что-то вроде на сервере, там часть рисуется на клиенте, потом мы восстанавливаем состояние при помощи инкрементальной регенерации. Давай так, как для каждого из этих трех штук выглядит страница? В случае, например, с клиент-сайд-рендерингом эта страница будет пустая, в ней будет только JS. Соответственно, мы на клиентесайд-рендерингом, эта страница будет пустая, в ней будет только JS. Соответственно, мы на клиенте начинаем рисовать. В случае с SSR у нас полностью будет генерированная страница присылаться на клиент. На клиенте мы будем его отрисовать. В случае с инкрементальной отрисовкой мы, получается, насколько я понимаю... Там не инкрементальная, мне SSG static site generation интересно. Там, получается, будет нам присылаться статика, но не будет состояния, оно будет нам присылаться в Next при помощи особого пропса и потом восстанавливаться на клиенте. А в SSR? Еще раз. В SSR состояние не высылается? В SSR оно, по-моему, уже должно быть отрисовано на сервере. Насколько я помню. Там, по-моему, делается... Так, Давай назад. При static site generation страницы, короче, как выглядит? Ну, это статика, получается. Там пусто или не пусто? Там не пусто. При SSI там пусто или не пусто? При SSI там тоже не пусто. Что такое регидратация? Регидратация – восстановление состояния страницы, то бишь JS-хендлеры навешиваются, все остальное. Так, на снаб... Ну, окей, хорошо. Что такое веб-сак это? Протокол общения между сервером и клиентом, который используется в основном для реал-тайм-ивентов различного рода. Это отдельный протокол. Например, получение сообщений, триггерится. Когда стоит его использовать, а когда просто же тебе? Когда есть большое количество различного рода взаимодействий сложных, когда прям нужен real-time и мы не хотим использовать long-pulling или short-pulling на фронтенде для подтягивания данных. То есть мы либо посылаем запросы с фронта постоянно триггер и сервер, иногда такое не подходит, нам нужно что-то другое. Вот сокеты как раз подходят. У меня тут стоит такой вопрос сравнения. Можешь, пожалуйста, сравнить отличия REST, GraphQL и Solta? В REST, по сути, у нас там endpoint получается есть, которые мы сами делаем. Мы не определяем структуру запроса. У нас есть определенные импоиты, мы не можем получить обратно те поля, которые мы хотим. То, что нам отдает REST, то он и отдает. В GraphQL мы на клиенте можем задавать то, что мы хотим получить от сервера вплоть до каждого поля. И там также в GraphQL есть схема. Насколько я знаю, она генерируется схемой, и по этой схеме мы можем типизировать наше приложение. В случае с REST нам нужно самим делать интерфейсы, описывать и так далее. А с endpoint-ами в GraphQL? С endpoint-ами в GraphQL там получаются точно такие же endpoint-ы, насколько я помню. Единственное различие, что ты можешь на клиенте, типа, ты пишешь на поло-клайенте файлики, которые определяют, какие конкретно поля ты хочешь получить. Вот, с бэкэнда. Так, а в чем отличие с open-а от их Нехабылых? С Соупом, если честно, не работал Ну, по-хорошему Посмотри потом, все-таки надо будет Просто иногда, короче, про него Нас обеспрашивают, особенно всякие бифтефи А вообще где-нибудь Применяется? Короче, в основном Legacy Gavnia Потому что А вообще где-нибудь применяется? Короче, в основном Legacy-говне, потому что это скорее некий стандарт Java, который реализовался в сервисах, которые в нулевых были сделаны. Сопы-то, когда мы на серваке что-то тянем. Это тоже про перебячу данных. Типа не REST, а процедуры вот эти. Так, про JS. Расскажи мне, наверное, разделив на две категории, вообще вот типы данных, какие две основные категории там есть? Простые и объект. Те, которые по значению и по ссылке. Хорошо. Какие простые заходят? Ну, стринги, например, strings, numbers, чтоные те, которые по ссылке у нас работают, соответственно, это объекты, объекты, это мапы, сет мап. Что там еще у нас есть? Массивы и мапы. Массивы это отдельный тип или нет? Массивы и мапы. Массивы это отдельный тип или нет? Массивы это... Массивы, массивы, массивы, да. Нет, подожди, это объектный тип данных. Да, это объект. Массивы это объект. А в чем отличие м MAP от объекта? Мап от объекта в том, что... Ты имеешь ввиду MAP? Ну как? NewMap? Да. Тем, что он используется для создания уникальных значений получается то есть мы создаем некий уникальное значение и там есть у него свои методы для работы Так, можешь мне рассказать про слово var и letto const, в чем их отличие? Почему одно у вас минимум другое? У var глобальная область видимости, у него нет блочной области видимости, у letto const ограничена область видимости блоком. Основное их отличие. А вот чем таким специальным свойством обладает фвардинг? Поднятие. А что это такое? Это когда мы можем, например, определить где-то внизу, то есть мы можем использовать значение которого нету, оно где-то определено внизу, мы можем где-то вверху его использовать. Расскажи мне, пожалуйста, что такое Event Loop? Какую проблему у вас в жизни? Event Loop – асинхронную логику, работа с асинхронными задачами. Реализуется при помощи вебе, при помощи браузера. Это асинхронными задачами. Реализуются в вебе при помощи браузера. Это синхронная очередь задач. Давай так, если бы у нас не было бы EventLoop в языке, чем бы нам это грозило? Тем, что у нас не работала бы асинхронная операция. Что это значит? То бишь операции типа setTimeout, promise и все остальное, она работает при помощи EventLoop. Что значит? Мы бы тогда не могли бы запустить setTimeout или что? Его просто не было бы. То есть, он сам по себе, setTimeout реализуется при помощи браузера. В JS в принципе нет setTimeout. Корректно. Без браузераного API у нас не получится его запустить, в принципе. То есть, в том плане, что сам по себе event loop, он не уникальный для браузера, то есть, в ноде он тоже есть, но там своя имплементация. В браузере своя имплементация. Смотри, вот, короче, есть Python. В Python, ну, по молчанию event loop там тоже нет. Там там буквально ручками короче включить пайкан также как и gs это по сути обертка над сишным кодом и соответственно всякие а его операции запросы в сеть запросов базу данных все ост остальное, делается сс-с-с-код. При этом в Python есть запросы в сеть, и в Python можно, короче, делать запросы в BD. Но там EventClub как бы нет. То есть получается немножко нестыковка с тем, что ты рассказываешь. Не, ну в любом случае мы бы без EventClub не смогли бы запускать в принципе эти функции, потому что это является частью браузера. Но чисто в теории мы могли бы сами написать что-то похожее. Но нам бы пришлось бы имплементировать эти функции, потому что это является частью браузера. Но чисто в теории мы могли бы сами написать что-то похожее. Но нам пришлось бы имплементировать эти функции, если бы у нас не было браузера и венкупа. Давай еще раз. Задача для типа в чем? В том, чтобы работать с асинхронными операциями. Вот, слово асинхронное мне нравится. Да, я сразу сказал. Нет, я понимаю. Я про то, что, короче, асинхронность не означает, что ты не можешь сделать запросы в сеть. Ну да. Асинхронность что означает? То, что ты выполнишь какую-то операцию и можешь ее дождаться. Асинхронно, не блокируя поток. Вот про это, пожалуйста, больше расскажи. Ну, то, что мы не блокируем поток ввода-вывода и, соответственно, у нас эти операции синхронно выполняются в неком отдельном Event Loop. Но поток синхронный у нас продолжает работать. У нас они, соответственно, параллельно работают. В том плане, что у нас сначала должен освободиться синхронный поток, а потом выполнится то, что в Event Loop. Но при этом то, что мы запускаем в Event Loop, оно не блокирует текущий поток. Текущий поток выполняет, Джейн. Я здесь на самом деле про конкуренси просто хотел услышать, но ладно. Расскажи мне тогда про микро-макро-таски. Макро-задачи это, например, SetTimeout. У них приоритетность получается меньше, чем микро-таски. Микро-таски это, например, Promises. Есть еще рендеринг. У нас выполняется сначала микро-задача, потом макро-задача, потом рендеринг. У нас, соответственно, выполняется сначала микрозадача, потом макрозадача, потом рендеринг. То есть все микрозадачи, потом одна макрозадача, потом рендеринг. Вопрос такой, кстати, странно задавали на одном из собесов. Что такое делегирование событий в JavaScript? Насколько я помню, это когда мы делегируем выполнение какой-то функции на другой объект. То есть мы выполняем эту функцию, но с другим объектом. Не совсем. Это про навешивание одного ивента вместо пяти. Ну ладно. А замыкание что такое в JSON? Замыкание это когда у нас наша функция запоминает контекст, в котором была вызвана. Ну и соответственно может использовать его даже после завершения функции. То есть у нас одна функция внутренняя, она помнит внешнее окружение, в котором была вызвана. Давай просто проектировать в голове функцию с замыканием. У нас здесь функция фу, что она будет возвращать, скорее всего? OnDefined, если ничего не определено внутри. Ну, если у не определено внутри. Если у нас return нет, то никакого что-то имени. Но тут есть функция full. Просто full. Она ничего не возвращает, она возвращает undefined. Вот в одном из редакторских компонентов где может использоваться closure? Посмотри. Так, а здесь что такое? Здесь контекст выполнения, соответственно, мы можем манипулировать контекстом выполнения. При помощи bind, apply и... Да, вот кстати, как его менять короче? Bind, apply и call. А в чем это отличие? bind возвращает новую функцию соответственно дата выполнения apply и call call вызывает с одним аргументом, apply с массивом аргументом. С Bind приходилось к этому проводить? Было дело, да. Как тебе? В основном на старых проектах. Я имею в виду, в смысле какой-нибудь кейс назови. Нужно было переопределить ZIS в одной из функций, чтобы она использовала определенный другой ZIS. Не тот, который есть, а тот, который надо мне. А в React классе приходилось с какой-нибудь работать? С Bind нет. В основном SP с трестрелочной функцией. Что такое прототипное наследование и как оно в JS реализовывается? Прототипное наследование, то что у нас есть прототип, соответственно от него мы можем наследоваться. Соответственно в JS реализовано именно прототипы наследования. Когда у нас есть какой-то прототип, на основании него мы делаем новые классы и они наследуют все его свойства. Через какое полеах наследоваться от других? В Е6 классах есть ли приватные, публичные, протект от поля? Что там из этого есть? Ты можешь модификатор доступа менять, private делать. Если что, правочный же звание про TypeScript. Там Sharp есть, насколько я помню, в последней. Почему он делает? Делает поле неизменяемым. Что такое статический метод класса? Который мы можем вызвать в объекте, даже когда не создан инстанс. То есть он привязан именно к самому классу. Так, хорошо. Какую проблему промисс решает? Промиссы, промиссы, промиссы. Ну, с точки зрения для чего они были сделаны, этот промис хэл починить. То есть у нас был промис хэл, когда, не промис хэл, а колбек хэл. Когда у нас куча колбеков, колбек с колбеком из-под колбека, промисы соответственно это дело упрощали. Каким образом они об этом деле упрощали? Ну, то, что там соответственно, это дело упрощали. Каким образом они об этом деле упрощали? То, что там, соответственно, из промиса можно при помощи ченнинга ждать другой промис, и так далее. Какие состояния промисов ты знаешь? Fulfilled, pending, rejected, вроде все. Ну, результат еще. Резолт, да. А давай так вот проведем, короче, вот сам начат, когда промиссы даешь, он в каком состоянии находится? Пендинг. Если произошла ошибка, это какой мыс? Резолт. Если все хорошо? Resolved. Какие статические методы промиссов ты знаешь? Статические, then. Then. Статические. А, подожди. Promiss all, race. Смотрите, в одних спаджинных стандартах, хотя уже давно, был добавлен еще All-Settled. С чем разница между All-Settled? когда хотя бы один зарезовывался, а all только когда все зарезовывались. Насколько я помню. Теперь такой вопрос. Нахрена нам в стандарте осенковайтесь, у нас уже есть промисы? Он упрощает код, делает его линейным. Соответственно, мы можем... В ZEN мы делаем код в виде промисов, у нас ченится и так далее. В 3Catch мы, соответственно, делаем более линейный, похожий на асинхронный код. Чем вращает асинхронная функция? Промис. Чем внутри этого промиса подлежать? Все из-за того, что мы возвращаем. Соглашаем. Так, как в CSS определяется, какое правило было применено к элементу удара? Ну, так как это каскадная таблица стилей, у нас есть некая каскадная... у нас есть приоритетность этих тегов, соответственно там ID-шники, например, имеют приоритет над классами, у классов приоритет меньше, чем у ID-шников, потом у нас идет еще селекторы обычные, то есть можем просто элемент селектить. И соответственно там есть такое правило, что есть конкретно взаимосвязь между ID и классом. То есть там сколько бы не было классов, ID все равно будет больше, но при этом если будут два одинаковых ID, то если к ID будет еще класс, то больше будет То есть правило специфичности. Как нам нарушить это правило и сделать так, чтобы все здесь подходит? Какие основные отличия SCSS от CSS? В SCSS расширенный синтакс, и, соответственно, мы можем делать вложенные в селекторы. То есть, когда у нас там and и так далее. Также там есть переменные. Ну, именно как сказать, именно в CSS там свои переменные есть отдельные, не те, которые в обычном CSS. Просто их не было в CSS в оригинале. И там есть миксины, всякие там дополнительные штуки в CSS есть. Они расширяют. Такой вопрос. Браузеры умеют исполнять CSS? Нет, не умеют. А что тогда это потом? CSS превращается при помощи плагина пост-CSS. Ты упомянул, что в CSS есть переменныеенные и они другие относительно CSS, а чем разница? Ну они там немножко по-ываются под капотом. Я здесь просто хотел сказать, что их воронтайне менять можно. Что-то да, у них такое есть, типа воронтайне. Окей. Я не работал. Окей. CSS и JS в чем их в отличие от предыдущих двух? И в плюсы и минусы, может быть, какие-то скажешь. CSS и JS преимущество в том, что мы... Давай, извини, что перебиваю. Например, отставок компонент. Да. В том, что мы работаем, мы можем работать с CSS как с JS, по сути. То бишь мы... Ну, CSS и JS это... Мы, по сути, делаем некий компонент. Его при помощи функции styled мы его стилизуем, соответственно мы пишем в нашем js-exe, это sx-e файлы стиле и соответственно мы можем работать с ss-mk, sgs, то бишь там переменные, вычисляемые значения и так далее. Для меня основное преимущество это то, что оно как бы все в одном файле, тебе не нужно делать отдельный файл CSS, но соответственно у тебя может быть вообще в одном файле. Давай так, что из этого работает быстрее? CSS или стелс компонент? Да хороший вопрос. Вообще нативный CSS, CSS и CSS работают, по идее, быстрее, чем... А стайлт как работает? Стайлт перед тем, как отобразиться, он, насколько я знаю, превращается сборщиком в нативный CSS. Ну, то есть, он как бы не создается в CSS заран есть, он как бы не создается в CSS заранее, он типа... Да. Поэтому, ну, в любом случае, медленнее будет работать. Окей. Как CSS решает проблему коллизии селекторов? Ну, если мы говорим про этот React, допустим, там мы модули делаем. CSS-модуль это уже CSS-нgs, я про классические CSS говорю. Можно ли это как-то решить? Честно, не сталкался с этим, но... Как бы ты решил? По-моему, миксинами как-то подменять классы. Смотри, ситуация, значит, ты сидишь... Типа определенный префикс давать. Давай такую ситуацию, значит, ты сидишь на проекте, короче, пилишь сайт. Да. По какой-то причине там был выбранный CSS и, соответственно, как бы ничего такого нет. Но при этом сайт большой, приходит к тебе подмастерье, и ты ему даешь задачу, чтобы это сделать. Как, вот, что бы ты ему сказал, чтобы он, короче, внезапно не наебнул бы кнопку, например, не перекрасил в сену, или там, чтобы он не сломал твой код? Ну, какой-то префикс можно сделать, если ты про это определенный для каждого из компонентов. А какие-то определенные, так сказать, правила, подходы, знаешь, как минимизировать возможность коллизии? Ну как минимум модульно код писать, скорее всего. Ну, BEM, например, можно использовать. Да, можно использовать какие-то методологии типа BEM, например. Окей. И сейчас больше люди склоняются в сторону Tailwind и utility first class. эти ферст-классы. В чем, кстати, раз ты про Телленд сказал, в чем отличие от Телленда от обычного классического CSS? В том, что он, по сути, задает стили в формате классов. То есть ты пишешь классы, и эти классы, так называемые UTILS-классы, они содержат, соответственно, какие-то кусочки разметки. То есть какой-то CSS определенный. Ты из этого CSS собираешь стили. Смысл в том, что они максимально переиспользуемые, эти классы, и ты их можешь по всему проекту использовать. А как в Индии, знаешь, настраивать короче цвета и всякие-всякие? Там есть темы, можно тему свою сделать конкретное место можешь сказать? там есть файл настройки это winconfig так пара React это последний двух вопросов что такое virtual DOM? virtual DOM это виртуальный дом в реакции он решает проблему того, что у нас есть узкая горлышко при работе с JavaScript и HTML, это модификация DOM-дерево. Они очень медленные, очень эффективные и так далее. Виртуальный DOM это копия настоящего DOM, которая, соответственно, в реак React сделана для того, чтобы оптимизировать как раз такие операции с домдеревом. То есть React сам определяет момент, когда нужно обновить домдерево, и при помощи этого облегченной обертки с ней легче работать, он потом эти апдейты применяет на настоящий дом. Да. Можешь мне писать, как происходит вообще вот этот вот цикл обновления, короче, пересовки в реакте? Там, если что, я хочу три слова, короче, услышать. На него вот в реакте... У нас есть жизненный цикл, который мы можем прицепиться. Как это происходит в функциональных компонентах, у нас есть хуки, которые при помощи этих хуков мы можем затриггировать апдейты стейта. Ладно, я немножко не туда, а про триггеры, рендеры и комметы можешь мне рассказать? Ну, мы, по сути, триггерим апдейты каким-то образом, например, изменение значения new state. Как еще можно триггерировать помимо setState? Что еще является триггернуть помимо setState? setState... Что еще является триггером? useEffect useEffect это скорее sideEffect, когда у тебя происходит триггер. ну да. Вот у тебя один короче setState, а что еще может компонент пересовывать? Рендер. Но это в классах. Нет, рендер это уже следствие. Это уже следствие. Вот дочерние компоненты, которых нету стоит, но они тоже пересовываются. Дочерние компоненты пропсы. Пропсы из сайт стоит и пропит. Так. Рендер и коммит. пропсы. Пропсы из Сетсета это пропыль. Так, рендер и коммит. Что такое? Можешь их как-то попробовать сам рассказать? Ну, рендер это, собственно, рендер например, нашего компонента. Что время рендера происходит, короче? Время рендера у нас получается случай, например, с компонентом, он у нас перерисовывается, соответственно функция выполняется заново, соответственно весь код внутри выполняется заново. Нет, тут лучше посмотри потом, прям отдельно на реакцию, в реакции есть прямая докумация. Неплохая статья. С какими React-функами ты работал? Какие-то основные штуки. UseState, UseEffect, UseRef. Какие параметры UseEffect принимает функция? UseEffect. Там получается массив зависимости да, первая callback функция которая должна выполнить что эта callback функция может вернуть? она может вернуть функцию и тогда эта функция выполнится на Unmaunt компонента. Только при анмаунте? Нет, в зависимости от того, что мы пропихнули в квадратных скобках, если они пустые, то только при анмаунте. Если в них есть какие-то зависимости, то каждый раз, когда у нас триггерится. Согласен. А как в React-хуках, в React-компонентах, короче, функциональных сделать типа аналог поля класса? В классе можно вис, типа А равняется 1. Это все-таки не стейт, но это как бы переменная, которая... Да. Кастомные хуки писал? Да. Можешь какое-нибудь описать? Ну, например, клик outside. То есть у нас надо было проверять то, что мы нажали вне элемента. Соответственно, туда пропихивался ref. И мы смотрели, мы кликнули на этот элемент или в ней его. Либо закрывали, либо не закрывали. Можешь мне кратко описать движение экшена и до изменения стора в редаксе? Какие пути он проходят? Мы его диспатчем. Дальше он отправляется в редюсер, где мы определяем. Не совсем. До редюсера куда он может отправить? Иногда даже после этого редРД все не доходит. Это если санк мы используем. Там либо санка, либо... А санка на каком уровне проверяется? Санка, вот как раз, когда мы делаем диспатч, получается. Ты делаешь диспатч, потом попадаешь? Давай так, санка на каком уровне, корочене регистрируется? На уровне мы после вызова по идее должны зарегистрировать это самка или это обычный экшен. Отправить его в middleware. То есть заходит middleware, потом проверяется это самка или не самка, если самка, то больше всего не остановит. Что является значением возвращаемого из редюсера? Новый стейт, причем копию нового стейта, для того чтобы затриггерилсяый стейт. Причем копию нового стейта. Для того, чтобы у нас затриггировался апдейт. Согласен. Так, ваш стоп в JSX превращается после компиляции, транспиляции? JS. Более конкретно можешь вы называете? В зависимости от бандлера, который используется в случае с Бэйбелем это какой-нибудь ES5, то, что мы выбрали в настройках. А функцию помнишь, которая GSX превращается? Ну, APD при рендере... Не помню честно сказать. Если ты имеешь ввиду именно React API, не помню честно Вот он. А, ну, значит, креатив. Скоро будет он. Ну, просто под капотом все это делает. Да, да, да. Ну, просто некоторых людей ставят в тупик, да, то, что, короче, те говорят, типа, вот он превращается, типа, копируется по HTML. Это просто в корне неправильно. Так, давай, наверное, последний вопрос. Какие методы оптимизации компонентов ты знаешь? Задача такая. Тебе приносят таблицы, она там возит. Большая таблица, короче. Что вот куда ты станешь копать дальше? Виртуализация. Что ты мешаешь? То есть мы виртуальный список делаем. Пагенация, например. Это с точки зрения больше к серверу относится. Можем на фронте сделать в целом. На фронте тоже может помочь, если надо количество элементов уменьшить. Мимоизация, но это немножко не к этому. Почему? Можно, да, мимоизировать, но обычно пробуют сначала первые вот эти подходы. Мимоизация, что нам позволяет? Ну, перерисовки. То есть мы уже при повторном ререндеринге компонента какие-то штуки можем не перерисовывать. Это как перерисовка, мы говорим про что? Про UseMem или ReactMem? UseMem, например. ReactMemo это больше про children, то есть если у нас есть какие-то child-компоненты, которые мы не хотим перерисовывать. А если сам компонент таблицы является children, в котором копы влетают, мы же можем GD10 тоже уменьшить? Ну да, в принципе, и так, и так. Окей. А чем отличить useMemo от useCallback? UseCallback применяется на функции, useMemo применяется на обычных значениях. У меня вопросов больше нет. Ким, давайте мы теперь попрекучимся. Мы немножко перескочили. Я пишу сейчас, кстати, в наш общий чат про то, как мы должны проводить. Все-таки давайте вернемся к базе, с которой начинаются все собеседования, все скрининги. Это рассказ про свой опыт и про знакомство, рассказ о себе как о специалисте, как ты пришел в ту точку, в которой ты сейчас находишься, что ты как специалист знаешь, умеешь, и дальше рассказать про свой хотя бы последний проект. У нас сейчас времени не так много, поэтому фокусируемся на твоем последнем проекте. Расскажи, что за проект, чем ты занимаешься, какие задачи выполняешь, какие результаты твоей работы, чем ты можешь перед нами похвастаться, что ты сделал, И дальше мы немножко несколько вопросов зададим по разным ситуациям рабочим, как ты с ними сталкивался, не сталкивался, справляешься, не справляешься и так далее. Давай начнем. Знакомство пропусим уже на этот раз, наверное, давай с проекта. Последний проект, да? Да. ведение в целом опыта надо. Надо сейчас. Без времени мы уже потратим час почти. Почему? Это несколько предложений достаточно. Я работаю с React, Native, Tech, Script, еще 15 лет. На таких-то проектах умею то-то, то-то. Все, этого достаточно. Несколько предложений. Это хорошо. Я работаю с React в основном. Вот, фронтенд-разработчик. В основном Stack React, Next.js, соответственно, Redux, различного рода технологии с этим связаны. Дальше про проекты. Про проекты работал, собственно работал с разными проектами. Например, на Северстале делал импортозамещение проект, когда мы создавали систему, которая отслеживала различного рода вещи на предприятиях. То есть брак, различного рода какие-то состояния, поставщики и так далее. Табличная верстка была в основном. Там достаточно много было кода, достаточно много было модулей, большая была команда, микросервисная архитектура, соответственно, и достаточно высоконагруженное приложение было, которое я помогал реализовывать. Собственно, там разработал несколько модулей с нуля. Какие-то модули я дорабатывал. Например, Transfer Master данных это система передачи сообщений между там заводом и другим заводом, например. Вот я помогал реализовывать, именно дорабатывал. Модуль отклонений, например, когда мы показываем какие-то отклонения на производстве в виде графиков, это я уже зарабатывал с нуля полностью. То есть вы это завистили до конца нового проекта? Да. Закончился проект тем, что компания пошла на демо. Демо было в Москве и прошло как по успешному. А почему ты завершил проект? Насколько я помню, там что-то вопрос по деньгам шел. То есть они захотели дальше вот что-то такое. То есть вот. Там все в принципе разошлись. Это Северсталь. Соответственно, был проект про ВТБ наверное не стоит рассказывать. Ну, он так закончился. Типа того, так закончился. Там был факап какой-то с вашей? Ну, типа того, да, можно так сказать. Какая разница? Ты же не будешь говорить, что я это время не подарил. Ну, в принципе, да. Товальше рассказать об опыте, который ты там получил и привнес. В общем, ладно. По ВТБ там был кредитный анализ. Собственно, там были модули по анализу клиентов, то есть клиент приходит и компания ВТБ должна его проанализировать в кредитную историю. Соответственно, там тоже было достаточно сложное приложение. Там я помогал реализовывать просчитывание там ипотеки, соответственно, там был достаточно сложный тоже модуль, где я помогал реализовывать различного рода новые фичи. Ну и соответственно, фиксить те баги, которые были. Ты можешь подключаться технически, если есть какие-то вопросы по конкретному кейсу, по конкретному проекту, ты можешь подкидывать какие-то вопросы наводящие? Пока задавайте. Саша, были какие-то негривиальные решения, над которыми пришлось думать, внедрять? Собственно говоря, что Саша сказал? Что такое сложного, да? Ну вот, например, на модуле в Севереверстале например одном из модулей там нужно было придумать то как отрисовывать отклонение на производстве то есть там мы при помощи канвасов рисовали от эти квадратики то есть надо было придумать как нам отрисовывать, сколько занимает брак, место. Все это надо было отрисовывать за реальное время. Было достаточно много входных данных, мы оптимизировали код, чтобы он работал корректно. Также, например, была еще история с тем, что именно на Северсталь у нас была диаграмма Ганта достаточно сложная, то есть там были производственные процессы на диаграмме Ганта и нужно было придумывать, как из этого всего собирать график. Вот. Тоже вот такие вот, два таких нано-кейса самых. А, ну, пожалуйста, на Северстале остановимся, если у тебя больше какой-то вызывает интерес этот проект, ты прямо с энтузиазмом рассказываешь, как вот был построен процесс работы команды, насколько большая вообще команда была? Команда где-то человек 10-15. Тех лиды, штыки 3. Фронтов было где-то 5. Несколько аналитиков было. И тестировщики, соответственно. Процесс был построен так, что в начале аналитики разрабатывали юзер-кейсы, на основании которых, если мы рассматриваем фичи, на основании которых делался, их утверждали получается, если нужен был дизайн, дизайн делался. На основании этого разработчики уже разрабатывали фичи. В дальнейшем именно по этим ю вот юзеркейсам тестировщики проверяли код, что он соответствует. Ну и дальше это дело все выкатывалось, соответственно, сначала на тестовые площадки на df, потом соответственно на production, если все проверки проходили. Примерно так. А как была релизная политика выставлена вообще на проект? Релизная политика была выставлена, что у нас были спринты, и в течение спринтов там, получается, версионирование было некоторое. То есть мы выкатывали это как пакеты, и, соответственно, у вас повышается релиз получается, у вас повышается версия и вы релизите новую версию. Так как эта штука должна была встраиваться еще в другие пакеты. Понятно. Ну что, спасибо. Ты, Раблон, получается, как ударенный сотрудник, я так понимаю, команда тоже у тебя была распределенная. В основном, да. Как ты устраивал свою коммуникацию с коллегами, с командой, с заказчиками, так, чтобы это было максимально эффективно и... и вот. Ну, собственно, там был менеджер, во всех проектах, соответственно, был менеджер, к которому, собственно, в случае чего я мог обращаться, в основном он разруливал эти моменты с тем, что надо с кем-то связаться, или какие-то вопросы решить, так как все распределенные. Но если надо было, я и сам проявлял инициативу, писал, связывался, не стеснялся спрашивать коллег. В основном все через менеджера делалось. Это такая точка входа для всех. То есть менеджер организовал встречи коллективные? Ну конечно, и он соответственно артефакты потом какие-то оставлял после встреч. Расскажи, пожалуйста, как у вас строилось взаимоотношение с аналитиками? В смысле процесс работы с аналитиками? Процесс работы с аналитиками, во-первых, они участвовали в созвонах, не всегда, но зачастую, и, соответственно, они могли что-то спрашивать. Каждую неделю проводилось такое собрание груминг, где мы обсуждали новые фичи, и, соответственно, аналитики могли что-то корректировать, если что-то не подходило. В основном все так же делалось в сервисе менеджера, если были какие-то вопросы, то как пишет менеджер, он связывался с аналитиками нужными, не занятыми и так далее. То есть ты напрямую с ними не взаимодействовал? Взаимодействовал достаточно редко. В основном через менеджера, потому что надо было, чтобы артефакты какие-то оставались. Напрямую вообще плохо общаться. Были ли кейсы, когда приходили от аналитиков сформированные требования в виде юзкейсов? Ты упомянул юзкейсы, и ты, читая их, понимал, что там ерунда написана, то есть не то, что нужно. Зачастую, да. Что ты делал в такой ситуации? Зачастую сформ. Что ты делал в такой ситуации? Зачастую сформировано некое ТЗ, техническое задание на разработку, и там все по юзкейсам расписано, однако зачастую не соответствует это все действительности, потому что аналитиков нет понимания того, как работает фронтенд. Ну, соответственно, приходилось связываться с аналитиками, объяснять ситуацию, и мы вместе находили там решение. Вот, соответственно, они перерабатывали и бизнес-кейсы, и юзер-кейсы, и требования. Подгоняли, подгоняли под там реалии. Я правильно понимаю, что ты сам пошел, инициировал контакт и помогал им разобраться в ситуации, чтобы вы вместе сделали в итоге то, что будет отвечать тем требованиям, которые вам нужны для разработки. Да, да, да. Отлично. Скажи, пожалуйста, у тебя были какие-то конфликтные ситуации с членами команды или там с лидами? Конфликтов там не было с вас. Ну давай писаю, что вот у тебя возникла ситуация конфликтная с кем-то из членов команды, какое-то недопонимание, какие твои действия будут в такой ситуации, что ты будешь делать, чтобы не видеть конфликт? Чтобы примерно такое было, связывался обычно с менеджером, и, соответственно, с ним решал этот вопрос. То есть сразу на эскалировали? Нет, я подсвечивал момент, что есть такой-то кейс. И, соответственно, спрашивал, какие мои дальнейшие действия. Но сам ты не пытался решить конфликт, не эскалируя, не подсвечивая? Смотря с чем он связан. Если он связан со мной, я, конечно, пытаюсь решить конфликт. Если он связан с другим членом команды, например, с бэкэндером, который что-то, например, не сделал, то тут как бы с его стороны что-то должно быть. Давай я поясню. Скажем так, я не эскалировал, если проблема связана со мной, я пытался решить. Давай разыграйную сценку короче. Вот он ПМ, я бэкер, пидарас, ты отмечаешь и контракт. Я не представляю тебе опиху. И, соответственно, тебя блокируют. Твои действия. Я постоянно не даю это. Саботируют. Пойду к менеджеру, если буду спрашивать. Со мной не можешь говорить? Первоначально я, конечно, узнаю, в чем может быть проблема, загвоздка. Если меня этот ответ не устраивает, я иду к менеджеру. Смысл убить человека. Давай я фишку. Давай мы сейчас закончим и разберем кейс. Были ли у тебя случаи, когда ты давал оценку, но в итоге ты в свою оценку не попадал, из-за чего задерживал поставку какой-то питча или вся команда задерживалась? В целом было, но в основном это было связано с тем, что требования поменялись в последний момент. Какие были твои действия? Мои действия были связаться с менеджером и, соответственно, продумать дальнейшие действия. Это на Северостале было в таком моменте. Но в итоге решили просто релиз сдвинуть. А ты связался с менеджером и ты ему как преподнес ситуацию? Требования поменялись. Смотри, из недели времени до конца задачи оставалось 3 дня. В середине недели, соответственно, 3 дня остается, меняются полностью требования. И, соответственно, я свяжусь с мужем, но требования поменялись. И, соответственно, он со своей стороны уже ищет какой-то вариант решения проблемы и они просто сдвигают релиз. Давай представим такую физическую ситуацию, что темы не менялись, все осталось как есть, но ты просто был в плохом состоянии духа, ты плохо прочитал требования и неправильно оценил задачи. Вот ты на половине пути понимаешь, что ты никак не успеваешь в эти сроки. Какие твои действия будут здесь? Менеджер, здравствуйте. Потому что он может решить вопрос о том, что может быть кого-то можно к тебе подсадить, кто больше знает, например, или перевести задачу другого человека или что-то еще такое. В любом случае первый, кто узнает, это менеджер. Так, ну в целом, Маша, есть какие-то вопросы еще дополнительные? Вопросов нет, я вам три свои замечания. Давай, да, перейдем к обратной связи. Да. В целом, давай. Ты начнешь или? Да, начинай, давай ты. Хорошо, я так, какие-то моменты, которые можно улучшить, не то чтобы это замечание, но их можно улучшить. Когда ты с вопросительной интонацией переспрашиваешь, это дает ощущение того, что ты неуверенно знаешь то, о чем говоришь, либо в принципе не знаешь. Постарайся, пожалуйста, из своих ответов управлять слова, насколько я знаю, скорее всего. Лучше ты скажешь, как ты думаешь, без этих сложных слов. И будешь говорить, как будет. Ну, я знаю, вот так. Еслиучше ты скажешь, как ты думаешь, без этих сложных слов. Ну, я знаю вот так. Если это неправильно тебя поправит, вы начнете рассуждать, как вы делали с Артемом. В общем, такие условные слова поразить, их не нужно. Они уменьшают ощущение того, что ты понимаешь, о чем говоришь. Вот, я заметила, что если ты хорошо знаешь собственно ответный вопрос, ты быстро отвечаешь и рассказываешь. Если же ты чего-то не знаешь, нам нужно подумать, как этот вопрос решить. Либо, опять же, начинать рассуждать, либо задавать наводящие вопросы. Потому что несколько раз такие моменты промелькивали. На примере промеса. Ты начал, Артем тебе что-то про промесы задал, вопрос, и ты начал промисы, промисы, промисы, как будто воспоминая, пытаясь что-то придумать. Как вариант, что я у себя записала, что может тебе помочь. Например, также начинать рассуждать касательно того, что промисы допустят, условно с теорией, промисы это то-то, они работают там-то, там-то. Ты это знаешь, как бы просто произносишь, и, возможно, параллельно ты найдешь уже какой-то ответ на этот вопрос. Либо тебя точно так же интервьюер уже направит в то русло, в котором ты, скорее всего, знаешь, что тебе потребуется ответить. И, например, когда Артем задал тебе вопрос, писал ли ты кастомные хуки, ты просто сказал, да, писал. Здесь, наверное, стоит заблаговременно дать сразу более развернутый ответ не ждать пока у тебя спросят какие он тебя задает вопрос пишешь писал эти кастомные хуки ты не что писал вот это вот это и вот это будет скажем на переживание мне кажется сразу информации на тебя спросили писал или нет. Я сейчас объясню, сейчас смотри. В таком случае, короче, надо отвечать, да, писал, вас интересует что-то конкретное. Все, дальше тебе задают вопрос, как я расскажу. Если ты вместо этого начинаешь рассказывать, да, писал, тоже бы понимание, что лучше было бы сказать, да, писал, у меня там в таком-то проекте было там что-то там. Можно пойти один пример. Просто в короткий пример да, у меня вот на проекте было, я сделал вот это. Все, этого достаточно. Да, ваш вопрос конкретно даже про хунки, ты ему спросил, писал, он ответил, да, ты спросил, какие, и Саша сказал два предложения какие, ты сказал, ок сказал окей хорошо пошли дальше ну скажем не ждать пока тебе задают вопрос пару предложений сказать если не захотят они более детально если ты действительно с этим работал если ты действительно хорошо это знаешь ты более развернута коричневой да нет да нет сразу так раз и пояснении На этом у меня все В целом некоторые вот эти замечания устранить Будет еще лучше, чем На самом деле все весьма хорошо Я думаю, что дополню Я уже по группе сказал Очень классно, когда ты будешь На какие-то моменты Слаться на свой опыт Всегда это показывает, что ты не просто это вызубрил А ты прям с этим работал Ты знаешь, как это делать, ты потрогал физически уже технологию, решение и прочее. Если есть такой опыт, вспоминай его и интегрируй, короче. Саша так и делает. Да, много моментов есть, не забывай это делать постоянно. То же самое относится к софтовым кейсам, вопросам. Старайся их искать в своем реальном опыте. И это покажет, что ты с этим столкнулся и уже знаешь, как с этим быть. У тебя часто были ответы, что я пойду к менеджеру, это сделает менеджер, это он ответственный. Он может показать, что делегирование... Это скорее говорит о том, что ты такой, типа, это задача, я туда не лезу. Это неплохой ответ, так можно делать. Просто важно показывать, что тебе не все равно на ситуацию. Ну понятно. И ты можешь передать, и ты позаботился о том, чтобы ситуация не вышла по контролю, и передал это ответственному человеку. Но ты можешь также эту ситуацию взять в свой контроль и попытаться что-то первым делом сам сделать, а если уже не пошло, пойти к менеджеру. И это покажет твою большую вовлеченность и инициативность для людей. Вот, допустим, ситуация с бэкэндером-педрасом. Ты пошел, у тебя есть с ним конфликт Ты видишь, что он тебя саботирует Не отдает опиху, ты идешь и говоришь Артем, один на один сервис Я заметил, что у нас такая ситуация Давай разберемся, что происходит Потому что ты И себе не очень хорошо делаешь Мою работу блокируешь Так не делай, мы вместе работаем, нам надо найти какое-то решение Сначала поговорим А если он говорит, ты не ты нахуй, ничего тебе давать не буду, ты тоже пидарас. Тогда ты идешь к менеджеру, разбираешь кейсы и менеджер уже решает. Короче, мой бой в том, чтобы все такие моменты всегда пытаться сначала найти решение самому. Сначала горизонтально решаешь, а потом решаешь. Да, потому что они очень любят свои команды, вот тут, что у нас команда, туда-сюда. Опять же, как ты сам сказал, 10-15 человек это большая команда, достаточно для вас. Поэтому, когда умеешь сам решать какие-то вопросы, это для них очень явно. 10-15 человек вообще в принципе команда большая, на самом деле, не было бы проекта. Я думаю, что... Что? Будем проводить второй? Я не вижу смысла проводить. Саш, ты молодец. Ты хорошо проходишь на последних совместках, это понятно. Учесть какие-то замечания высказали. По технической части тоже как то. По технической я тебе там отправил, короче. Если у тебя будут вопросы, можно обсудить. Спасибо тебе за время. Спасибо. Ну, тоже спасибо. Подождите хочется воду, мало. Да, какие-то штуки типа соупP я слышал, но не сталкивался. Про SOP суть какая, короче. Все, что я наоборот, на тебя в этом видео. Радик. Все вот эти вот ресты, джейсона, пикграфки, это все про то, чтобы как чтобы сформировать запрос как нашел необходимую и отдал тебе необходимую в ресте что является какие которые позволяют сервер найти необходимую функцию? Хендлер. Хендлер это конкретная штука, конечная. Вот сам пакет, вот что ты на фронте задаешь? Заброс. Понятно, что в запросе? Заглобок, метод, body ну, какого-то основного, еще главное что? URL, как говорил да, а в GraphQL? схема запроса схема запроса URL один или несколько? по-моему, один в листе? ну, при запросе ты один делаешь. Нет, нет, в смысле разделение в листе. А, там много урлов. Супер, знаешь? Короче, смотри. Настал его. Смотри, чтобы найти необходимую, ну, чтобы передать всю необходимую информацию серверу, чтобы он, короче, выдал тебе ответ. В ресте ты должен выбрать один из нескольких импоинтов, потому что в каждом импоинте есть никакая информация. Потом ты должен передать необходимый метод, потом ты должен передать необходимые хедеры. И вот, по этим данным он найдет тебе соответствующие, короче, обороныованные запросы. У GraphQL у тебя один endpoint, и ты передаешь туда под JSON и вот этот вот запрос, короче, пиздец. И там дальше, короче, он как-то с этим магическим. В Slope тоже один endpoint. Ага. По-моему. Вот, там, в отличие от GraphQL и REST, там используются XML. И основные данные по запросу, куда что чего стучать, вот так всё будет в XMD. Это жёстко. Короче, это типа устаревший GraphQL. Интересно. Я просто знаю, есть ещё RPC. Но это больше, наверное, кстати, RPC похоже. Есть, по-моему, RPC еще удаленный вызов процедур ремонт но это, по-моему, вообще другая хуйня там, Сул, по-моему, тоже, кстати, генерис как открыт, как GPC, короче ну, почитаю вообще, по-моему, это как обычно ну, да я сейчас встроил уже все
в верстке JavaScript и React. Первый вопрос относительно верстки. Первый вопрос достаточно общего характера. Какие есть в CSS инструменты для разработки адаптивной и кросс-браузерной верстки? Медиазапросы в CSS. Для того, чтобы сделать верстку для разных экранов разной.  Ну и также у нас есть еще метатег viewport, когда мы его делаем, верстка адаптируется для мобильных экранов. Хорошо. По поводу кросс-браузерной верстки, может быть, сталкивались с этим? Кросс-браузерная, да. Ну там, по сути, у нас используется для...  У нас, по сути, используются для cross-браузерной верстки так называемые префиксы. Браузерные префиксы, веб-кит и веб-кит из примеров. Да, отлично. Представьте себе, что перед вами стоит такая задача. У вас есть приложение CSS-файлы, и вы бы хотели в этих CSS-файлах  хотели в этих CSS-файлах расставить вендорные префиксы. Каким образом это можно было бы сделать? Ну, есть, собственно говоря, расширение AutoPrefixer, которое это делает автоматически. Какое расширение? Можете пояснить? Ну, в S-коде ставится расширение AutoPrefixer, и когда ты сохраняешь файл, он автоматически добавляет префиксы. Подождите, Александр, в каком S-коде? Нам нужно, чтобы у клиентов в сборке... В сборке, я понял, да.  Я понял, да. Просто надо было пояснить тогда, что у клиентов сборки. Александр, нас весь код вообще не интересует. Нам нужно расставить интернет-эпиксы, чтобы у клиентов была кроссбраузерная верстка. У клиентов. В сборчике это делается. Настраиваются модули. Каким образом? Добавляется в конфиг веб-пак. Конфигурация. Автопрефиксер добавляется в конфиг. Что такое автопрефиксер?  Что такое автопрефиксер? Ну, это пакет, который, NPM-овский, который, собственно говоря, добавляет автоматический префиксер. Да, согласна с вами, отлично. Давайте тогда пойдем дальше. Представьте себе, что вам с помощью CSS нужно рисовать такую фигуру. Красный круг, а внутри белый прямоугольник. Ну, знаете, знак дорожного движения, кирпич. Каким образом это можно будет сделать? Position абсолютом, например, можно сделать.  Можно сделать. Если именно сами элементы, ну, именно круг и треугольник отрисовать, например, то можно, например, при помощи Canvas отрисовать. Можно, например, использовать, импортировать два изображения треугольника и круга и абсолютом их посадить. Вот. Можно бордерами нарисовать. То есть сказать, что именно нужно, ну, задать, чтобы белый прямоугольник поместить в середине красного круга. Белый прямоугольник в середине красного круга.  прямоугольных соединений красного круга. Ну, красный круг у нас будет z-индекс, например, допустим, один, смотря как они должны располагаться. Если, ну, получается, z-индексами мы задаем, что-то будет внизу, что-то будет вверху, получается. То есть мы при помощи position absolute мы их ставим на одно место, например, и по сути z-индексами мы там один поверх, один элемент и от другого он становится. Например, там этот квадратный  этот квадрат вписывается в круг. Так, хорошо. А как мы именно в середину прямоугольник переместим? Ну, есть топ-50, left-50, и надо будет transform-translate сделать, минус 50% и для x, и для y. Отлично, спасибо большое. Давайте тогда пойдем дальше, перейдем к JavaScript. Первый вопрос тоже общего характера. Какие типы данных  Какие типы данных есть в JavaScript? Может вспомнить встроенные коллекции данных, которые есть в JavaScript? Ну, собственно, простые и объекты. Простые — это, собственно, number, begin, string, boolean, null, undefined, symbol и все. И второй тип данных — это объектный. Собственно, в простом мы по значению рассчитываем,  По значению работаем в объектном, у нас по ссылке работает передача значений. Отлично. А может быть, помните коллекции, данные встроенные? Мэп и сет есть. А зачем они нужны? Собственно, мэп для создания коллекции. И, собственно, в нем отличие от объектов в том, что в нем можно ключ любого типа создавать. Не только стринк, а любого типа.  типа. То есть для работы с коллекциями. Set – это уникальный набор данных. То есть мы уникализируем какой-то набор данных. И значения могут встречаться только один раз. В сете. Собственно, set тоже объект. Извините, я может прослушала. А чем map отличается от объекта? Map в качестве ключа может использовать любые значения, не только string. Хорошо.  Хорошо, ну да, согласна с вами. Следующий вопрос такой. В JavaScript есть цикл forIn и forOf. Чем они друг от друга отличаются? Чем они нужны? forIn для объектов, forOf для массивов. Что значит forIn для объектов, forOf для массивов? Непонятно.  непонятно. Ответ непонятен. Что мы перебираем, например, с помощью цикла forIn в объекте? Не, немного не так. Получается, да, forOf тоже для объектов, и forIn и forOf для объектов, но у нас получается,  нас получается for of он обходит но получается тренируем объекты которые можно тренировать вот он вызывает там операторы на каждом шаге получается выполнение вот и что что что что александр что такое на каждом шаге выполнения вы что-то читаете  Я не знаю, что это значит. Это правда высказывала. Мы, по сути, интерируемся по объекту и вызываем на каждом шаге какой-то оператор. Я про это имею в виду. На каком каждом шаге мы вызываем какой-то оператор? Я не поняла. Что значит на каждом шаге мы вызываем оператор? Мы берем, получается, объект, проходим по его свойствам, и на каждом свойстве мы вызываем какой-либо оператор. Это цикл формулы. Что значит мы вызываем какой-то оператор?  Что за оператор вы вызываете там? У нас есть объект. Если мы используем цикл for off или for in, мы проходим по каждому его свойству и делаем какой-либо callback, так называемый. Поняла вас, хорошо, поняла. То есть вы хотите сказать, что просто мы в цикле можем какое-то действие заложить, да? Вы это хотите сказать?  можно свойства в объекте хорошо хорошо все я понимаю пару бассейн вы рассказали хорошо спасибо давайте тогда пойдем дальше следующий вопрос такой дайте себе что вам из кода java script нужно отправить сетевой запрос на сервер каким образом это можно сделать с помощью  сделать с помощью активных методов JavaScript? Например, функция fetch. А можете рассказать, как работает fetch? Мы, собственно говоря, в fetch помещаем какую-либо ссылку, например, на сторонний веб-ресурс и, собственно говоря, вызываем в коде fetch. Fetch возвращает промис, которым мы можем дождаться и, собственно говоря, получить результат и что-то с ним сделать. Что будет, когда промис и результат  будет когда промис зарезал дается вот что вернет фэйс вернет ну собственно говоря этот response какой-то с данными которым можно дальнейшему обычно значит респонд что будет в этом диспансер объект объект респонса будет получается и дальше мы можем джейсон преобразовать вызвать метод джейсон у него  А объект response, что там внутри будет? Какие поля там будут? Ну, заголовок, статус, данные, дата, например, статус запроса, успешен, не успешен. Хорошо, а после этого нам данные получить как? Ну, сделать функцию JSON над response, взять response и.json и, собственно говоря, так получить данные, например.  для данной, например. Хорошо, а если у нас данные сейвера приходят не в формате JSON, а в другом формате? Ну, используя там дата, property data будет в респонсе. То есть, если JSON, нам нужно какой-то метод использовать дополнительный, а если нет JSON, то просто берем property data из респонса оригинального. Ну да. Поняла вас, спасибо. Следующим, давайте тогда перейдем к вопросам по React.  перейдем к вопросам по React. Первый вопрос тоже такого общего характера. Что такое React фрагмент и зачем он нужен обычно в React? React фрагмент — это получается элемент в React, которым мы можем оборачивать какие-либо компоненты в React. Так как у нас в React может быть одна корневая домнода, соответственно, мы можем оборачивать эти элементы в React, если нам нужно. И, собственно говоря, они никак в верстке не появляются.  в верстке не появляется. Мы не дивом обращаем, а как бы фрагментом, который до многих он никак не отображается. Да, отлично. Все так и есть, спасибо. Мой второй вопрос такой. Можете кратко описать, как работает кук UseEffect в реакции? UseEffect? Ну, собственно говоря, у нас при помощи UseEffect можно делать  эффекта можно делать допустим методы жизненного цикла эмулировать как в классах собственно говоря если мы например запускаем его с пустыми скобками из эффекта то он отрабатывает при маунте компонента если бы из него что-то возвращаем например функцию возвращаем то это эмуляция размонтирование компонента вот из эффект будет вызываться вызываться в мы можем виз эффект скобочки и авторы прописки  в скобочке его второй property определять какие-то переменные, при изменении которых будет этот useEffect запускаться. Что значит в скобочке? Что такое в скобочках переменные? Когда мы вызываем useEffect, там получается два у него аргумента. Он принимает первым аргументом callback, а вторым аргументом получается массив зависимости, при изменении которых, собственно говоря, он будет вызываться.  Так, хорошо. А вот если нам нужно какую-то функцию запустить перед тем, как компонент размонтируется? Ретурн сделать из эффекта. И, соответственно, он должен быть с пустыми скобками. Что такое с пустыми скобками? Ну, то есть мы второй аргумент, вот этот зависимости, массив зависимости делаем пустым и возвращаем какой-либо... То есть всегда у нас массив зависимости должен быть обязательно пустым?  должен быть обязательно пустым? Нет, не всегда. То, что мы хотим эмулировать, соответственно, этот метод жизненного цикла, когда размонтируется компонент, мы делаем пустыми скобками. Хорошо, а если у нас есть функция return, то есть у нас юзуэффект возвращает какую-то функцию, но при этом у нас массив зависимости не пустой, там есть какие-то переменные. Да, он будет вызываться каждый раз при вызове юзуэффекта.  Что будет вызываться каждый раз? Ну вот этот return. А вот, например, у нас есть в useEffect функция, например, setTimeout. В return мы возвращаем функцию clearTimeout, то есть даем интервал какой-то и его очищаем. Но при этом у нас массив зависимости не пустой. То каким образом эти функции работают? Так, массив зависимости еще раз не пустой. Да.  Да. Так. Set timeout. Clear timeout. Ну, по сути, у нас будет создаваться timeout, и он будет, получается, убираться при размонтировании этого компонента.  размонтировании этого компонента когда мы с него например выйдем допустим смотрите у нас еще компонент не разбантироваться но у нас какая-то переменная массиве зависимости изменилась вот каким образом сработают эти функции сайта переменная массиве зависимости  Если переменные не изменяются, то у нас не запускается useEffect. Он запускается, когда переменные меняются. Соответственно, он там первый раз... У нас переменная изменилась, useEffect у нас должен сработать. У нас как раз она изменилась. Да, запускается setTimeout, и потом он, получается, очищается. То есть timeout  То есть таймаута нет в итоге, да? Ну да. Поняла вас, спасибо. Следующий вопрос связан с формами. У нас на проектах, банковских приложениях часто используются формы. Достаточно часто. Поэтому вопрос такой. В React есть управляемые и неуправляемые input. Может быть, сталкивались с этим? Чем они друг от друга отличаются? Когда что лучше использовать? Ну, собственно, управляемые.  управляемые — это когда мы присваиваем какие-либо значения, то есть мы привязываем как бы input, и он зависит от каких-то переменных, например. Неуправляемые — получается, что мы не завязываем на какие-то значения NGS-овские input. И неуправляемые в основном используются, когда нужно оптимизировать, например, работу большой сложной формы, когда у нас множество перерисовок и множество изменений, собственно говоря, этих переменных,  собственно говоря этих переменных которые связаны и например и библиотека react-hook forms она как раз таки работает на на вот как раз не не связанных инпутах вот связаны собственно когда мы прям хотим жесткий контроль над значениями вот и ну и когда нам например нужно изменять ну то есть мы хотим например  То есть мы хотим, например, при изменении каких-либо переменных перерисовывать значения в input. Просто при неуправляемых там немножко другой механизм того, как меняется значение. Какой? Нативный. Мы используем ttrf, привязываем элементы и меняем у него value. Отлично.  Спасибо большое, отлично. Последний вопрос будет такой. Какие методы оптимизации веб-приложений вы знаете, сталкивались в практике? Веб-приложения, например, кэширование. Смотря что имеется в виду под оптимизацией.  которые пользователь грузит себе на компьютер, когда заходит на нашу страницу? Ну, вот как раз, например, кэширование. Для React, например, актуально lazy loading. Мы можем загружать страницу, когда она только используется. Когда мы на нее переходим, например. Каким образом это работает? Ну, React первоначально эту страницу никак не загружает. Когда, собственно говоря, мы переходим на эту страницу, React, JS, собственно говоря, определяет, что мы на ней... А что значит,  Что значит, что конкретно происходит, что конкретно React делает? Ну, проверяет, что мы по URL-странице, проверяет, что мы на ней или нет, и, соответственно, грузит ее или нет. Там есть так называемый suspend, можно компонент использовать, который, собственно говоря, заменит собой то, что мы загружаем.  Это лазилоудинг. Допустим, есть кэширование, то есть мы можем кэшировать какие-то веб-ресурсы, например, там картинки, текст. И, соответственно, уже при втором запросе, например, их не запрашивать, а уже из кэша брать. Но, соответственно, там есть проблема, что его нужно актуализировать, потому что данные могут поменяться, а кэш будет старый. То есть надо следить за тем, чтобы он был актуальный кэш.  А как с этим следить? Ну, ставятся различного рода параметры, допустим, на том же Nginx, чтобы инвалидировался. Подождите, Александр, мы про фронтенд говорим. Мы сами на фронтенд. Да, я понял. Давайте про фронтенд. На фронтенде, например, если мы используем какой-нибудь TANF такт-квери для запросов, который кэширует запросы, например, мы... Ну что, простите, что?  Ну, есть библиотека Tynestack Query для запросов. Какая? Какая? Еще раз. Ну, React Query она еще называется. React Query. React Query. React Query мы знаем, да. Хорошо. Вот, в ней, например... А, Tynestack Query вы имеете в виду, да? Да, в ней, например, есть параметр invalidate. Мы можем указывать, через сколько, конечно, например, будут устаревшие. Так, хорошо. Кэширование запросов. Да. Согласна с вами. С точки зрения фронта,  С точки зрения фронта, так, оптимизация. Мы можем использовать там современные форматы, например, изображений и современные форматы шрифтов, например, которые оптимизированы. То же самое с видео. Что еще мы на фронтенде? Мы можем сборку оптимизировать, чтобы там чанки оптимизировались, сборки, чтобы они там поменьше  поменьше их сделать, чтобы они быстрее грузились, получается. Ну, то есть там... А что значит поменьше их делать, чтобы они быстрее грузились? Сборщики можно настроить там размеры чанков и, соответственно, при манипулировании этим размером чанков, то есть он на определенной части делит JS-код и, соответственно, он, то бишь сборщик, он делит JS-код на эти чанки и потом при подгрузке он может, собственно, быстрее  может быстрее грузиться или медленнее, в зависимости от размера чанков. Я не понимаю, подождите, я не очень понимаю. Вот у нас, например, вся сборка JavaScript кода, она весит 2 МБ, да? Вы разделили это на 2 чанка по 1 МБ. Каким образом 2 чанка по 1 МБ загрузится быстрее, чем 1 чанк на 2 МБ? Вопрос.  Вопрос. Загрузится ли это быстрее? Ну, по идее, если это приоритизировать, какой из них, ну, типа, один загрузится быстрее, мы уже, например, будем использовать JS, а второй, например, мы будем дождаться, там, Async или Defer ему поставить, и, соответственно, можем дождаться, пока он загрузится. То есть мы можем уже пользоваться приложением. Ну да, согласна с вами. Приоритетность, да, сделать. Ну, обычно там библиотеки какие-то,  там библиотеки какие-то так хорошо согласно это еще все вроде бы основной ну основное да ну если с такого еще например можно но это уже не относится к фронту сжатия например gzip любое другое сжатие на том же in jingx но обычно джинсом делается но можно на фронтенде тоже сжимается сборщиками сборку собственно говоря  Зачем на фронтенде это сжимать? Да, это очень редко используется, в основном на том же Nginx. Зачем? У нас, если это, например, тот же самый, так как это HTML, когда мы сжимаем, соответственно, у нас уменьшается размер файла. Нет, я понимаю, как работает компрессия, я понимаю. Просто зачем на фронтенде это делать, если обычно это делается на Nginx? На фронте это редко используется, обычно на Nginx делается, на сервере делается.  Да, да, да. А может, на джинс мы заканчиваем, потому что у нас собеседование по фронтензу все-таки. Спасибо большое. Спасибо. Основные способы вы перечислили. Смотрите, у меня больше вопросов не осталось. Тогда я предлагаю вам рассказать о проекте и ответить на ваши вопросы. Хорошо? Хорошо. Хотелось бы узнать, что за проект, что там вообще используется. Вот, сам вам про проект больше. Да, конечно. Да, конечно. Сейчас как раз я вам все расскажу. И если какие-то будут вопросы,  И если какие-то будут вопросы по работе у проекта, то задавайте. Постараюсь ответить на то, что я знаю. Итак, проект, на который сейчас идет набор фонтен-разработчиков, называется «Интернет-банк для юридических лиц». Я думаю, что вы знакомы с приложением «Интернет-банк для физических лиц». В принципе, «Интернет-банк для юридических лиц» похож по функциональности. Там есть какие-то определенные... Не только он отличается по функционалу, но в целом похожи.  В целом, похоже, это приложение на интернет-банк для физических лиц. Это приложение уже на проде около полутора лет. Сейчас идет активная разработка страниц приложения. Также у нас, например, часто обновляются требования от Центробанка, и необходимо править уже существующий функционал. И также нужно будет разрабатывать страницы приложений, которые еще не успели.  которые еще не успели вывести на прод. То есть в основном работа будет идти вот в таком ключе. По стеку технологий это React TypeScript и также микрофронты. То есть то, что вы как раз рассказывали о предыдущих проектах. Сам проект, он достаточно объемный, поэтому работа над ним разбита между командами. Всего над проектом занято 6 команд, и эти 6 команд разбиты функционально. То есть есть команда, которая занимается кредитами,  Есть команды, которые занимаются кредитами, есть команды, которые занимаются картами и так далее. То есть каждая команда работает на своей небольшой функциональности. Состав команд одинаковый. Это руководитель проекта, веб-разработчик, это реактор-разработчик в нашем случае, мобильные разработчики, бэкэнд-разработчик, аналитик, тестировщик и дизайнер.  но так как вы работаете над одним приложением, то вы будете пересекаться с другими командами. И также у этих команд есть фронтовый темлит и бэкэнд темлит. Соответственно, задача уже темлитов — это непосредственно разработка архитектуры приложения, в целом настройка приложения, то есть какие-то такие основные, основополагающие вещи по архитектуре в основном. А задача уже разработчиков — это доработка функциональности.  функциональности. Так, наверное, это такая основная информация по проекту. Может быть, у вас есть какие-то вопросы? Так. Проект вообще, ну, получается, на долгое время или нет? В целом, по времени? Ну, проект... Ну, каких-то прям... Предполагается, что разработчики сейчас, они закончат разработку в целом проекта, а затем нужно будет его поддерживать.  а затем нужно будет его поддерживать, так как у нас постоянно есть какие-то новые требования от Центробанка, новые потребности от бизнеса, поэтому да, такой проект долгосрочный. А бэкэнд, получается, там на чем он вообще? Смотрите, бэкэнд у нас на C-Sharp, но у нас фронт-энд разработчики, они вообще не имеют отношения к бэкэнду. Понятно.  Понятно. Ну так, вроде бы по вопросам. Вроде бы и все. Отлично. Тогда, если у вас появятся вопросы, вы можете их задать через Артема. Дальнейшим. Спасибо вам большое. Хорошего вам дня. До свидания. Спасибо. Все, спасибо.
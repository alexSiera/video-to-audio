вопросов вёрстки, JavaScript и React. Первый вопрос относительно вёрстки, первый вопрос достаточно общего характера. Какие есть в CSS инструменты для разработки Разработки адаптивной и кросс-браузерной новости. Ну и также у нас есть еще метатег viewport, когда мы его делаем, собственно, там верстка адаптируется для мобильных экранов.Так, хорошо. По поводу кросс-браузера. Кроссбраузерная, да. Ну, там, по сути, у нас используется... У нас, по сути, используется... Используются для кроссбраузерной верстки так называемые префиксы, браузерные префиксы, веб-кит. Ну вот, из примеров. «Расставить вендорные префиксы» — каким образом это можно было бы сделать?  В VS-коде ставится расширение, автопрефиксер, и когда ты сохраняешь файл, он автоматически добавляет прессу. Простите, Александр, а в каком VS-коде? Нам нужно, чтобы у клиентов в сборке... В сборке, я понял, да. Просто Просто надо было пояснить тогда, что у клиентов сборки... Александр, нас весь код вообще не интересует. Нам нужно расставить вендорнет-эпиксы, чтобы у клиентов была кросс-граузерная верстка. У клиентов. Но в сборщике это делается с монострацией. Настраивается модуль и добавляется в конфигурацию пака. Но это пакет, который, NPM-овский, который, собственно говоря, добавляет автоматический пресс к самому. Да, согласна с Вами, отлично. Давайте тогда пойдем дальше. Представьте себе, что нам с помощью CSS нужно нарисовать такую фигуру.  Если именно сами элементы, то это может быть очень важным.  сами элементы, ну именно круг и треугольник отрисовать, например, то можно, например, при помощи Canvas отрисовать. Можно, например, использовать, импортировать два изображения — треугольник и круга и абсолютом их посадить. Можно и бордерами нарисовать. — То есть сказать, что именно нужно, ну, задать, чтобы белый прямоугольник поместить в середине красного круга? — Белый прямоугольник в середине красного круга? Ну, красный круг у нас будет этот индекс, например, допустим, один, ну, смотря как они должны располагаться. Если, ну, получается, z-индексами мы задаем, что-то будет внизу, что-то будет вверху, получается, вот, то есть мы, типа, Мы при помощи позиции абсолют мы их ставим на одно место, например, и по сути с этими индексами мы один элемент от другого становится. Например, этот квадрат вписывается в круг. А как мы именно в середину прямоугольник переместим? — Ну, есть топ-50, left-50, и надо будет transform-translate сделать минус 50% и для X, и для Y.  Да, отлично. Хорошо, отлично, спасибо большое. Давайте тогда пойдем дальше, давайте перейдем к JavaScript. Первый вопрос тоже общего характера. Какие типы данных есть в JavaScript? Может вспомнить встроенные коллекции данных?  Ну, собственно, простые и объекты. Простые — это, собственно, number, begin, string, boolean, null, undefined, symbol, symbol. Символ и всё.И второй тип данных — это объектный. Собственно, в простом мы по значению работаем, в объектном у нас по ссылке работает. Отлично. А может быть, помните коллекции данных, встроенные, которые сейчас… Мэп и сет есть. А зачем они нужны? Мэп для создания коллекций, и, собственно, в нем отличие от объектов в том, что в нем можно ключ любого типа создавать. Не только стринк, а любого типа. Вот, то есть для работы с коллекциями. Сет — это уникальная это уникальный набор данных, то есть мы уникализируем какой-то набор данных, и значения могут встречаться только один раз в сете. Собственно, сет тоже объект. Извините, я может быть прослушала, а чем map отличается от объекта? Map в качестве ключа может использовать любые значения, не только string. Хорошо, ну да, согласна с вами. Следующий вопрос такой, в JavaScript есть На скрипте есть цикл forIn и forOf. Чем они друг от друга отличаются, зачем они нужны? — forIn для объектов, forOf для массивов на скрипте, да. Что значит «урок для объектов, урок для массивов»? Непонятно. Ответ непонятен, так? Мы перебираем, например, с помощью цикла forIn в объекции. Нет, немного не так. Получается... «For off» тоже для объектов и «for in» «for off» для объектов, но у нас получается «for off». Он обходит, ну, получается, трирум объекта, который можно трировать, вот, и он вызывает там оператора на каждом шаге, получается, выполнения, вот, и... Мы, по сути, призываем все, кто хочет, чтобы мы не были внести в это вред. Мы, по сути, интегрируемся по объекту и вызываем на каждом шаге, собственно говоря, какой-то оператор. Я про это имею в виду. На каком каждом шаге мы вызываем какой оператор? Я не поняла. Что значит на каждом шаге мы вызываем оператора? Мы берем, получается, объект, проходим по его основам. по его свойствам, и на каждом свойстве мы вызываем какой-либо оператор. Это цикл формулы. И когда мы используем цикл for off или for in, мы проходим по каждому его свойству и делаем какой-либо callback, так называемый. То есть вы хотите сказать, что просто мы в цикле можем какое-то действие заложить, да? Вы это хотите сказать? — Мы перебирать можем свойства в объекте этими двумя методами. — Так, свойства в объекте, ага, хорошо, поняла вас, ага, с помощью цикла forIn. Поняла, угу. Я думаю, что это будет очень полезно для всех. Помните себе, что вам из кода JavaScript нужно отправить сетевой запрос на сервер. Каким образом это можно сделать? С помощью активных методов JavaScript. Например, функция fetch. А можете рассказать, как работает fetch? Мы, собственно говоря, в фетч помещаем какую-либо ссылку, например, на сторонний веб-ресурс и, собственно говоря, вызываем в коде фетч. Фетч возвращает промисс, к которой мы можем дождаться и, собственно говоря, получить результат и что-то с ним сделать. с ним сделать. А что значит «респонс»? Что будет в этом «респонсе»? Объект «респонса» будет, получается, и дальше мы можем JSON А объект-респонс, что там внутри будет? Какие поля там будут? Ну, заголовок, статус, Статус данной даты, например, статус запроса, успешен, неуспешен. Хорошо. А после этого нам данные получить как? Ну, сделать функцию JSON над респонсором, взять респонсор, И, собственно говоря, так получить данные, например. Хорошо. А если у нас данные севера приходят не в формате JSON, а в другом формате? Ну, использовать там дата, property data будет в... То есть если JSON, то нам нужно какой-то метод использовать дополнительный, а если не JSON, то просто берем пропорт цитаты из оригинального респонса?  Поняла Вас, спасибо. Следующим давайте тогда перейдем к вопросам по React. Первый вопрос тоже такого общего характера. Что такое React фрагмент и зачем он нужен обычно в React? React фрагмент это получается элемент в React. Компоненты. если нам нужно. И, собственно говоря, они никак в этой верстке не появляются. То есть мы не дивом обращаем, а как бы фрагментом, который как бы до многих он никак не отображается. Ну, собственно говоря, у нас нас при помощи юзу эффекта можно делать допустим методы жизненного цикла эмулировать как в классах собственно говоря если мы например запускаем его с пустыми скобками юзу эффекта то он отрабатывает при маунте  при маунте компонента. Если мы из него что-то возвращаем, например, функцию возвращаем, то это эмуляция, размонтирование компонента. UseEffect будет вызываться, мы можем в UseEffect эффект, в скобочке, в авторовой property, ну, собственно, определять какие-то переменные, при изменении которых будет этот юз эффект запускаться. Ну, это значит, в скобочке, в столь такой скобочке, какой-то с кубочками переменный. Когда мы вызываем юзуэффект, там, получается, два у него аргумента. Он принимает первым аргументом коллбэк, а вторым аргументом, получается, массив зависимости, изменение которых, собственно говоря, он будет вызываться. А вот если нам нужно какую-то функцию запустить перед тем, как компонент размонтируется? Ретурн сделать из эффекта, и, соответственно, он должен быть  но он должен быть с пустыми скобками. Что такое с пустыми скобками? Ну, то есть мы второй аргумент вот этот зависимости, массив зависимости делаем пустым и возвращаем какой-либо... То есть всегда у нас да, у нас массив зависимости должен быть обязательно пустым. Нет, не всегда. То, что мы хотим эмулировать, соответственно, этот метод жизненного цикла, когда размонтируется компонент, мы делаем пустыми скобками. Так, хорошо, а есть А если у нас есть функция return, то есть у нас юзуэффект возвращает какую-то функцию, но при этом у нас массив зависимости не пустой, там есть какие-то переменные. Да, он будет вызываться каждый раз при вызове юзуэффекта. А вот, например, у нас есть в NewsEffect функция, например, SetTimeout. В return мы возвращаем функцию clearTimeout, то есть отдаем интервал какой-то и его очищаем. Но при этом у нас массив зависимости не пустой. То каким образом эти функции работают? Так, массив зависимости еще раз не пустой? Да. По сути, у нас будет создаваться тайм-аут, и он будет, получается, убираться при размонтировании этое изменение. Переменная массив зависимости. Если переменные не изменяются, то у нас не запускается юз эффект. Он запускается, когда переменные меняются.  Соответственно, он там первый раз... Вот у нас переменная изменилась, и эффект у нас должен сработать. У нас как раз она изменилась. Да, запускается setTimeout, и потом он, получается, очищается. То есть таймаута нет в итоге?  в итоге, да? Ну да. Поняла вас, спасибо. Смотрите, следующий вопрос связан с формами. У нас на проектах банковских приложений часто используются формы, ну, достаточно часто, поэтому...  Поэтому вопрос такой. В реакции есть управляемые и неуправляемые инпуты. Может быть, сталкивались с этим. Чем они друг от друга отличаются? Когда что лучше использовать? Ну, собственно, управляемые — это когда мы... мы присваиваем какие-либо значения, то есть мы привязываем как бы input, и он зависит от каких-то переменных, например. Неуправляемые, получается, что мы не завязываем на какие-то значения NGS-овские input. И неуправляемо в основном используется, когда нужно оптимизировать, например, работу большой сложной формы, когда у нас множество перерисовок и множество изменений, собственно говоря, этих переменных, которые, ну, И, например, библиотека React Hook Forms, она как раз-таки работает на вот как раз несвязанных инпутах. А связанные, собственно, когда мы прям хотим жесткий контроль над значениями. И когда нам, например, нужно изменять… Ну, то есть мы хотим, например, при изменении каких-либо переменных перерисовать. перерисовывая значения в input. Просто при неуправляемых там немножко другой механизм того, как меняются значения. Какой? Нативный мы используем Мы используем татарьев, привязываем элементы и меняем маневры. Какие методы оптимизации веб-приложений Вы знаете, сталкивались на практике? Смотря что имеется в виду под оптимизацией, если, например, имеется в виду... Каким образом это работает?  React первоначально эту страницу никак не загружает, когда, собственно говоря, мы переходим на эту страницу React.js, собственно говоря, определяющую... А что значит, что конкретно происходит, что конкретно React? Проверяют, что мы на ней или нет, и, соответственно, грузят ее или нет. Там есть так называемый саспент, можно компонент использовать, который... Собственно говоря, заменит собой то, что мы загружаем. Это lazy loading. Допустим, есть кэширование. То есть мы можем кэшировать какие-то веб-ресурсы, например, там картинки, текст, вот, и, соответственно, уже при втором запросе, например, их не запрашивать, а уже из кэша брать. Вот. Но, соответственно, там есть проблема, что его нужно как бы актуализировать, потому что данные могут поменяться, а кэш будет старый. То есть надо следить за тем, чтобы он был актуальный кэш. А как за этим следить? Ну, ставится...  различного рода параметры, допустим, на том же Nginx, чтобы инвалидировался... — Так, подождите, Александр, мы про фронтенд говорим. Мы с вами на фронтенд. — Да, я понял. — Ну, так, давайте про фронтенд. — На фронтенде, например, есть... Если мы используем какой-нибудь TansTagQuery для запросов, который кэширует запросы, например, мы... То что, простите, что? Ну, есть библиотека TansTagQuery для запросов. Какая, какая? Еще раз. Ну, реально... «React Query» она еще называется. «React Query» вы знаете, да. «PenStack Query» вы имеете в виду, да? Да. В ней, например, есть параметр «Invalidate». Мы можем указывать, через сколько кэш, например,  Например, будут устаревшие. Так, хорошо, кэширование запросов, да, согласна с вами. С точки зрения фронта, так, оптимизация, мы можем использовать Можем использовать современные форматы, например, изображений и современные форматы шрифтов, например, которые оптимизированы. То же самое с видео. Что еще мы на фронтенде? Мы можем сборку оптимизировать, чтобы чантки оптимизировать сборки, чтобы они поменьше грузились.  поменьше их делать, чтобы они быстрее были сможет решать. Сборщики можно настроить там размеры чанков и, соответственно, при манипулировании этим размером чанков, то есть он на определенной части делит JS И, соответственно, он, то бишь сборщик, он делит JS-код на эти чанки, и потом при подгрузке он может, собственно, быстрее грузиться или медленнее, в зависимости от размера чанков. Я не понимаю, подождите, я не очень понимаю, вот у нас, например, JS-код, К примеру, вся сборка JavaScript-кода весит 2 Мбайт. Вы разделили это на два чанга по 1 Мбайт. Каким образом два чанга по 1 Мбайт загрузятся быстрее, чем один чанг на 2 Мбайт? Вопрос — загрузится ли это быстрее? Если один загрузится быстрее, мы уже, например, будем использовать JS, а второй, например, мы будем дождаться, там, Async или Defer ему поставить, и, соответственно, можем дождаться, пока он загрузится. То есть мы можем уже пользоваться приложением. Ну да, согласна с вами. Проритетность сделать. Ну, обычно там библиотеки какие-то. Так, хорошо, согласна. Что-то еще? Все вроде бы. И, скажите, вы основное перечислили, да? «На фронтенде» тоже сжимается сборщиками. Зачем на фронтенде-то сборку сжимать? Да, это очень редко используется, в основном на том же Nginx. Зачем?  если это, например, тот же самый, ну, так как это HTML, когда мы сжимаем, соответственно, у нас уменьшается размер файла. Нет, я понимаю, нет, смотрите, как работает компрессия, я понимаю, просто зачем на фронтенде это делать, если обычно это делается на фронтенде.  На фронте это редко используется. Обычно на Nginx делается. На сервере делается. На Nginx мы заканчиваем, потому что у нас собеседование по фронтензии все-таки. Спасибо большое. Спасибо. Основные способы перечислили. Смотрите, у меня больше вопросов.  Когда больше вопросов не осталось, тогда я предлагаю вам рассказать о проекте и ответить на ваши вопросы. Хорошо? — Угу, хорошо. Хотелось бы узнать, что за проект, что там вообще используется. — Да. — Вот, сам вам про проект больше. Да, конечно, да, конечно, сейчас как раз я вам все расскажу, и если какие-то будут вопросы по работе проекта, то задавайте, постараюсь ответить на то, что я знаю. Итак, проект, на который сейчас идет набор фонтен-разработчиков, называется «Интернет-банк для  банк для юридических лиц. Ну, я думаю, что вы знакомы с приложением интернет-банка для физических лиц. В принципе, интернет-банк для юридических лиц, он похож по функциональности. Ну, там есть какие-то определенные  Не толком он отличается по функционалу, но в целом похоже это приложение на интернет-банк для физических лиц. Это приложение уже на проде около полутора лет. То есть, в принципе, сейчас идет, скажем так, активное развивание. эффективная разработка страниц приложения. Также у нас, например, часто обновляются требования от Центробанка, и необходимо править уже существующий функционал. И также нужно будет  разрабатывать страницы приложений, которые еще не успели вывести на прот. То есть в основном работа будет идти вот в таком ключе. Постэк у технологий это React TypeScript и также микрофронты. То есть тоже  То есть то, что вы как раз рассказывали о предыдущих проектах. Сам проект, он достаточно объемный, поэтому работа над ним разбита между командами. Всего над проектом занято шесть команд, и эти шесть команд — Шесть команд разбили функционально. Есть команда, которая занимается кредитами, есть команда, которая занимается картами и так далее. Каждая команда работает на своей небольшой функциональности. Состав команд одинаковый. Это руководитель проекта.  Веб-разработчик — это реактор-разработчик в нашем случае, мобильные разработчики, бэкэнд-разработчик, аналитик, тестировщик и дизайнер. Соответственно, вы работаете в своей маленькой команде —  но также все равно, так как вы работаете над одним приложением, то вы будете пересекаться с другими командами. И также у этих команд есть фронтовый темлит и бэкэнд темлит. Соответственно, задача уже темлитов — это непосредственно разоружение  разработка архитектуры приложения, в целом настройка приложения. То есть какие-то такие основные, основополагающие вещи по архитектуре в основном. А задача уже разработчиков — это дорабатывать.  это доработка функциональности. Так, наверное, это такая основная информация по проекту. Может быть, у вас есть какие-то вопросы? Так. Проект вообще, ну, получается, Появляется, что разработчики сейчас закончат разработку проекта.  А А бэкэнд, получается, там на чем он вообще? Смотрите, бэкэнд у нас на C-Sharp, ну, у нас пронт-энд-разработчики, они вообще не имеют отношения к бэкэнду. Отлично. Тогда, если у вас появятся вопросы, вы можете их задать через Артема. Всего доброго.
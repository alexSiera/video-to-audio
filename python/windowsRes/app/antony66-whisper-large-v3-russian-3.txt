{
    "transcription": "вопросов вёрстки JavaScript и React. Первый вопрос относительно вёрстки, первый вопрос достаточно общего характера. Какие есть в CSS инструменты для разработки адаптивной кросс-браузерной вёрстки? Медиазапросы в CSS мы пишем для того, чтобы сделать, собственно, вёрстку для разных экранов разной. Ну и также у нас есть еще метатег viewport, когда мы его делаем, собственно, там верстка адаптируется для мобильных экранов.  Да, отлично. А вот представьте себе, что перед вами стоит такая задача. У вас есть приложение CSS-файлы, и вы бы хотели в этих CSS-файлах расставить вендорные префиксы. Каким образом это можно было бы сделать? — Есть, собственно говоря, расширение Auto-Prefixer, которое это делает автоматически. — Какое расширение? Можете пояснить? — В VS Code ставится расширение Auto-Prefixer, и когда ты сохраняешь файл, он автоматически добавляет... — Подождите, Александр, а как в VS Code? Нам нужно, чтобы у клиентов в сборке... — В сборке, я понял, да. Просто надо было пояснить тогда,  что у клиентов сборки. Александр, нас весь код вообще не интересует. Нам нужно расставить интернет-репиксы, чтобы у клиентов была кроссбраузерная верстка. У клиентов. В сборчике это делается. Настраиваются модули, добавляются. Каким образом? Добавляется в конфиг веб-пак конфигурация. Этот автопрефиксер добавляется в конфигурацию. Что такое автопрефиксер? Это пакет, который «НПМовский», который, собственно говоря, добавляет автоматический пресс к своему. Да, согласна с Вами, отлично. Давайте тогда пойдем дальше. Представьте себе, что Вам с помощью CSS нужно рисовать такую фигуру. Красный круг, а внутри белый треугольник. Ну, знаете, знак дорожного движения и кирпич. Каким образом это можно будет сделать? «Позишн абсолютом», например, можно сделать. Если именно сами элементы, ну, именно круг и треугольник отрисовать, Если мы хотим отрисовать треугольник, то можно при помощи Canvas отрисовать. Можно, например, импортировать два изображения треугольника и круга и абсолютно их посадить. Можно бордерами нарисовать. Несмотря как они должны располагаться. Получается, Z-индексами мы задаем, что-то будет внизу, что-то будет вверху, получается. То есть мы при помощи позиции абсолют мы их ставим на одно место, например, и по сути Z-индексами мы один элемент от другого становимся. Например, этот квадрат вписывается в круг. Хорошо. А как мы именно в середину прямоугольник переместим?  Ну, есть топ-50, left-50, и надо будет transform-translate сделать, минус 50% и для X, и для Y. Да, отлично. Хорошо, отлично, спасибо большое. Давайте тогда пойдем дальше, давайте перейдем к JavaScript. Первый вопрос тоже общего характера. Какие типы данных есть в JavaScript? Может вспомнить встроенные коллекции данных, которые есть в JavaScript? Ну, собственно, простые и объекты. Простые — это, собственно, number, begin, string, boolean, null, undefined, symbol и всё. И второй тип данных — это объектный. Собственно, в простом мы по значению работаем, в объектном у нас по ссылке работает передача значений. Вот.  А может быть, помните коллекции данных, встроенные, которые сейчас? Мэпы, сет есть. А зачем они нужны? Собственно, мэп для создания коллекций, и, собственно, в нем, отличие от объектов в том, что в нем можно ключ любого типа создавать. Не только стринга, а любого типа. То есть для работы с коллекциями. Сет — это уникальный набор данных, то есть мы уникализируем какой-то набор данных, Значения могут встречаться только один раз в сете. Собственно, сет тоже объект. Извините, я может прослушала, а чем map отличается от объекта? Map в качестве кулича может использовать любые значения, не только string. Хорошо, ну да, согласна с вами. Следующий вопрос такой. В JavaScript есть цикл forIn и forOf. Чем они друг от друга отличаются? Зачем они нужны? «For in» — для объектов, «for off» — для массивов. Что значит «for in» для объектов, «for off» — для массивов? Мне непонятно. Ответ непонятен, так? Что мы перебираем, например, с помощью цикла «for in» в объекте? Мне немного не так. Получается, да, for-off тоже для объектов и for-in, for-off для объектов, но у нас получается for-off, он обходит, ну, получается, трирум объекта, который можно трировать. И он вызывает оператора на каждом шаге выполнения. Мы берем, получается, объект, проходим по его свойствам, и на каждом свойстве мы вызываем какой-либо оператор. Это цикл for off. У нас есть объект. Если мы используем цикл for off или for in, мы проходим по каждому его свойству и делаем какой-либо callback, так называемый. Появляется, что в цикле мы можем заложить какое-то действие. А можно сказать, как работает фетч?  возвращает промис, который мы можем дождаться и, собственно говоря, получить результат и что-то с ним сделать. — Что будет, когда промис зарезоливается? Что вернет фетч? — Фетч вернет, собственно говоря, этот, респонс какой-то с данными, который мы можем в дальнейшем, ну, обычно... — А что значит респонс? Что будет в этом респонсе? — Объект... Объект респонса будет, получается, и дальше мы можем JSON преобразовать, вызвать метод JSON у него. А объект респонса, что там внутри будет? Какие поля там будут? Ну, заголовок, статус, данные, дата, например, статус запроса, успешен, неуспешен. Хорошо, а после этого нам данные получить? А если у нас данные сейвера приходят не в формате JSON, а в другом формате?  цитаты из оригинального респонса. Поняла Вас, спасибо. Следующий вопрос тоже общего характера. Что такое React фрагмент и зачем он нужен обычно в React? React фрагмент — это элемент в React, которым мы можем оборачивать какие-либо компоненты в React. Так как у нас в React может быть одна корневая домнода, соответственно, мы можем  Мы можем оборачивать эти элементы в реакции, если нам нужно. И, собственно говоря, они никак в верстке не появляются. Мы не дивом оборачиваем, а как бы фрагментом, который до многих он никак не отображается. Да, отлично. Все так и есть. Спасибо. Мой второй вопрос такой. Можете кратко описать, как работает кук юзэффект в реакции?  useEffect. Ну, собственно говоря, у нас при помощи useEffect можно делать, допустим, методы жизненного цикла эмулировать, как в классах, собственно говоря. Если мы, например, запускаем его с пустыми скобками useEffect, то он отрабатывает при маунте компонента. Если мы из него что-то возвращаем, например, функцию возвращаем, то это эмуляция, размонтирование компонента. useEffect будет вызываться, Мы можем в юзуэффект в скобочке и автора property определять какие-то переменные, при изменении которых будет этот юзуэффект запускаться. Что значит в скобочке, что такое в скобочках переменные? Когда мы вызываем юзуэффект, там получается два у него аргумента. Он принимает первым аргументом callback, а вторым аргументом получается массив зависимости,  Углубление которых, собственно говоря, он будет вызываться. Так, хорошо. А вот если нам нужно какую-то функцию запустить перед тем, как компонент размонтируется? Ретурн сделать из эффекта. И, соответственно, он должен быть с пустыми скобками. Что такое с пустыми скобками? Ну, то есть мы второй аргумент, вот этот зависимости, массив зависимости делаем пустым и возвращаем какой-либо,  То есть всегда у нас массив зависимости должен быть обязательно пустым? Нет, не всегда. То, что мы хотим эмулировать, соответственно, этот метод жизненного цикла, когда размонтируется компонент, мы делаем пустыми скобками. Хорошо, а если у нас есть функция return, то есть у нас юзуэффект возвращает какую-то функцию, но при этом у нас массив зависимости не пустой, там есть какие-то переменные? Да, он будет вызываться каждый раз при вызове юзуэффекта.  юзу эффекта. Что будет вызываться каждый раз? Ну вот этот ретерн. А вот, например, у нас есть в юзу эффекте функция, например, setTimeout. В ретерн мы возвращаем функцию клея timeout, то есть даем интервал какой-то и его очищаем. Но при этом у нас массив зависимости не пустой. То каким образом эти функции работают? Так, массив зависимости еще раз не пустой. По сути, у нас будет создаваться таймаут, и он будет, получается, убираться при размонтировании этого таймаута.  этого компонента. То есть когда мы с него, например, выйдем... Нет, вот допустим, смотрите, у нас еще компонент не размонтировался, но у нас какая-то переменная в массиве зависимости изменилась. Вот каким образом работают эти функции? Например, timeout и clear timeout. Так, переменная в массиве зависимости... Если перемены не изменяются, то у нас не запускается юз эффект. Он запускается, когда перемены меняются. Соответственно, он там первый раз... Вот у нас перемена изменилась, юз эффект у нас должен сработать. У нас как раз она изменилась. Да, запускается setTimeout, и потом он, получается, очищается. То есть таймаута нет в итоге, да? Ну да.  Ну да. Поняла вас, спасибо. Следующий вопрос связан с формами. У нас на проектах банковских приложений часто используются формы, достаточно часто. Поэтому вопрос такой. В реакции есть управляемые и неуправляемые инфоты. Может быть, сталкивались с этим? Чем они друг от друга отличаются? Когда что лучше использовать? Ну, собственно, управляемые — это когда мы присваиваем какие-либо значения  либо значения, то есть мы привязываем как бы input, и он зависит от каких-то переменных, например. Неуправляемые, получается, что мы не завязываем на какие-то значения NGS-овские input. И неуправляемые в основном используются, когда нужно оптимизировать, например, работу большой сложной формы, когда у нас множество перерисовок и множество изменений, собственно говоря, этих переменных, которые связаны. И, например,  библиотека react-hook-forms как раз-таки работает на как раз не связанных input. А связанные, собственно, когда мы прям хотим жесткий контроль над значениями. И когда нам, например, нужно изменять, то есть мы хотим, например, при изменении каких-либо переменных перерисовывать значения в input. А какой?  Вы знаете, сталкивались там практики.  А что конкретно происходит? Что конкретно React делает? По URL-странице мы проверим, что мы на ней или нет, и, соответственно, грузит ее или нет. Там есть так называемый саспент, можно компонент использовать, который, собственно говоря, заменит собой то, что мы загружаем. Это лазиловый. Допустим, есть кэширование, то есть мы можем кэшировать какие-то веб-ресурсы, например, там картинки, тексты,  текст, и, соответственно, уже при втором запросе, например, их не запрашивать, а уже из кэша брать. Но, соответственно, там есть проблема, что его нужно актуализировать, потому что данные могут поменяться, а кэш будет старый. То есть надо следить за тем, чтобы он был актуальный кэш. А как за этим следить? Ну, ставятся различного рода параметры, допустим, на том же Nginx, чтобы инвалидировался «Реакция на фронт-энд» — это то, что мы используем в данном случае.  Хорошо. А, canstackquery вы имеете в виду, да? Да, в ней, например, есть параметр invalidate. Мы можем указывать, через сколько кэш, например, будет устаревший. Так, хорошо, кэширование запросов, да, согласна с вами. С точки зрения фронта, так, оптимизация. Мы можем использовать там современные форматы, например, изображений и современные форматы шрифтов, например, которые оптимизированы. А что значит «поменьше их делать, чтобы они быстрее грузились»?  и, соответственно, при манипулировании этим размером чанков, то есть он на определенной части делит JS-код, и, соответственно, он, то бишь сборщик, он делит JS-код на эти чанки, и потом при подгрузке он может, собственно, быстрее грузиться или медленнее, в зависимости от размера чанков. Я не понимаю, подождите, я не очень понимаю. Вот у нас, например, вся сборка JavaScript-кода, она весит 2 мегабайта, да? Вы разделили это на 2 чанка по 1 мегабайт. Благодаря этому, мы можем заработать на более высоких ценах.  Ну, да, согласна с вами. Ну, обычно там библиотеки какие-то. Так, хорошо, согласна. Это еще все вроде бы основное перечислили, да? Сжатие, например, JZIP или любое другое сжатие на том же Nginx, обычно Nginx делается, но можно и на фронтенде тоже сжимать сборщиками. Сборку, собственно говоря. Зачем на фронтенде-то сборку сжимать? Да, это очень редко используется, в основном на том же Nginx. Зачем? У нас, если это, например, тот же самый, так как это HTML, когда мы сжимаем, соответственно, у нас уменьшается размер файла.  Я понимаю, что это работает в компрессии, я понимаю. Просто зачем на фронтенде это делать, если обычно это делается на сервере? На фронте это редко используется, обычно на Nginx делается, то есть на сервере делается. На Nginx, видите, мы заканчиваем, потому что у нас собеседование по фронтенде все-таки. Спасибо большое. Спасибо, основные способы вы перечислили. Смотрите, у меня больше вопросов не осталось. Тогда я предлагаю вам рассказать о проекте и ответить на ваши вопросы. Хорошо? Хорошо. Хотелось бы узнать, что за проект.  Да, конечно. Сейчас как раз я вам все расскажу, и если какие-то будут вопросы по работе проекта, то задавайте. Постараюсь ответить на то, что я знаю.  периодических лиц похож по функциональности. Это приложение уже на проде около полутора лет. Сейчас идет активная разработка страниц приложения.  и необходимо править уже существующий функционал. И также нужно будет разрабатывать страницы приложений, которые еще не успели вывести на прот. То есть в основном работа будет идти вот в таком ключе. Постэк у технологий это React TypeScript и также микрофронты. То есть то, что вы как раз рассказывали о предыдущих проектах. Сам проект, он достаточно объемный, поэтому работа над ним разбита между командами.  Всего над проектом занято шесть команд, и эти шесть команд разбиты функционально. То есть есть команда, которая занимается кредитами, есть команда, которая занимается картами и так далее. То есть каждая команда работает на своей небольшой функциональности. Состав команд одинаковый. Это руководитель проекта, веб-разработчик, это реактор-разработчик в нашем случае, мобильные разработчики, бэкэнд-разработчик, аналитик, тестировщик и дизайнер.  Соответственно, вы работаете в своей маленькой команде, но также все равно, так как вы работаете над одним приложением, то вы будете пересекаться с другими командами. И также у этих команд есть фронтовый темлит и бэкэнд темлит. Соответственно, задача уже темлитов — это непосредственно разработка архитектуры приложения, в целом настройка приложения. То есть какие-то такие основные, основополагающие вещи.  по архитектуре в основном. А задача разработчиков — это доработка функциональности. Так, наверное, это такая основная информация по проекту. Может быть, у вас есть какие-то вопросы? Так... Проект вообще, ну, получается, на долгое время или нет? В целом по времени? Ну, проект... Ну, каких-то прям...  что разработчики сейчас, они закончат разработку в целом проекта, а затем нужно будет его поддерживать, так как у нас постоянно, ну, есть какие-то новые требования от Центробанка, новые потребности от бизнеса, поэтому, ну, да, такой проект долгосрочный. А бэкэнд, получается, там, на чем он вообще? Смотрите, бэкэнд у нас на C-Sharp, ну, у нас фронт-энд разработчики, они вообще не имеют отношения к бэкэнду. Ну, так вроде бы по вопросам, вроде бы и всё.Отлично. Тогда, если у Вас появятся вопросы, Вы можете их задать через Артёма в дальнейшем. Спасибо Вам большое. Хорошего Вам дня. До свидания.Хорошо, спасибо."
}
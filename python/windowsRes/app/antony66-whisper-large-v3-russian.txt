вопросов вёрстки JavaScript и React. Первый вопрос относительно вёрстки, первый вопрос достаточно общего характера. Какие есть в CSS инструменты для разработки адаптивной кросс-браузерной вёрстки? Медиазапросы в CSS мы пишем для того, чтобы сделать, собственно, вёрстку для разных экранов разной. Ну и также у нас есть еще метатег viewport, когда мы его делаем, собственно там верстка адаптируется для мобильных экранов.  Для кроссбраузерной верстки используются так называемые префиксы, браузерные префиксы, веб-кит. Веб-кит из примеров. «Расставить вендорные префиксы». Каким образом это можно было бы сделать? Есть, собственно говоря, расширение «Автопрефиксер», которое это делает автоматически. Какое расширение? Можете пояснить? В S-коде ставится расширение «Автопрефиксер», и когда ты сохраняешь файл, он автоматически добавляет префиксы. Подождите, Александр, а в каком S-коде? Нам нужно, чтобы у клиентов в сборке… В сборке, я понял, да. Просто надо было пояснить тогда, что у клиентов в сборке... Александр, нас весь код вообще не интересует. Нам нужно расставить интернет-рефиксы, чтобы у клиентов была кроссбраузерная верстка. У клиентов. Ну, в сборчике это делается. Настраиваются модули, добавляются... Так, ага. Каким образом? Добавляется в конфиг веб-пак конфигурация... Ну, этот автопрефиксер добавляется в конфиг... Что такое автопрефиксер? Ну, это пакет, который, NPM-овский, который, собственно говоря, добавляет автоматический пресс к самому. Да, согласна с Вами, отлично. Давай тогда пойдем дальше. Представьте себе, что Вам с помощью CSS нужно рисовать такую фигуру. Красный круг, а внутри белый прямоугольник. Ну, знаете, знак дорожного движения и кирпич. Каким образом это можно будет сделать? Position абсолютом, например, можно сделать. Сколько элементов можно отрисовать?  допустим, один, смотря как они должны располагаться. Если, ну, получается, z-индексами мы задаем, что-то будет внизу, что-то будет вверху, получается, вот, то есть мы при помощи позиции абсолют мы их ставим на одно место, например, и, по сути, z-индексами мы там один поверх один элемент, а от другого он становится. Например, там этот квадрат вписывается в круг. Так, хорошо. А как, А как мы именно в середину прямоугольник переместим? Ну, есть топ-50, left-50, и надо будет transform-translate сделать, минус 50 процентов и для X, и для Y. Отлично, спасибо большое. Давайте тогда пойдем дальше, давайте перейдем к JavaScript. Первый вопрос тоже общего характера. Какие типы данных есть в JavaScript?  Объекты данных, которые есть в JavaScript?  Передача значений. Отлично. А может быть, помните коллекции, данные встроенные, которые сейчас... Мэпы, сет есть. А зачем они нужны? Собственно, мэп для создания коллекции. И, собственно, в нем... Отличие от объекта в том, что в нем можно ключ любого типа создавать. Не только стринк, а любого типа. То есть для работы с коллекциями. Сет — это уникальный набор данных.  уникальный набор данных, то есть мы уникализируем какой-то набор данных, и значения могут встречаться только один раз в сете. Собственно, сет тоже объект. Извините, я может прослушала, а чем мэп отличается от объекта? Мэп в качестве кулича может использовать любые значения, не только стринг. Хорошо, ну да, согласна с вами. Следующий вопрос такой. В JavaScript есть цикл, «For in» для объектов, «for off» для массивов.  мы перебираем, например, с помощью цикла forIn в объекте? Нет, немного не так. Получается, да, forOff тоже для объектов и forIn и forOff для объектов, но у нас получается forOff Он обходит, ну, получается, трирум объекта, который можно интерьеровать. Вот. И он вызывает там оператора на каждом шаге, получается, выполнения. Вот. И... — Ой, что, что, что, что, Александр? Что такое оператор на каждом шаге выполнения? Вы что-то читаете? Я не знаю, что это значит. — Ну, мы, по сути... — Это правда высказывала? — Мы, по сути, вызов... Ну, мы, по сути, Мы, по сути, итерируемся по объекту и вызываем на каждом шаге, вызываем, собственно говоря, какой-то оператор. Я про это имею в виду. На каком каждом шаге мы вызываем какой-то оператор? Я не поняла. Что значит на каждом шаге мы вызываем оператор? Мы берем, получается, объект, проходим по его свойствам, и на каждом свойстве мы вызываем какой-либо оператор. Это цикл 4.0. Что значит мы вызываем какой-то оператор? Что за оператора вы вызываете там? У нас есть объект. Если мы используем цикл 4.0... Мы используем цикл forOff или forIn, мы проходим по каждому его свойству и делаем какой-либо callback, так называемый. Так, поняла вас, хорошо, поняла. То есть вы хотите сказать, что просто мы в цикле можем какое-то действие заложить, да? Вы это хотите сказать? Мы перебирать можем свойства в объекте этими двумя методами. Так, свойства в объекте, ага, хорошо, поняла вас, ага, с помощью цикла forIn. Поняла. Так, хорошо. Ну, все, я понимаю, пару басивов вы рассказали. Хорошо, спасибо. Давайте тогда пойдем дальше. Следующий вопрос такой. Представьте себе, что вам из кода JavaScript нужно отправить сетевой запрос на сервер. Каким образом это можно сделать с помощью активных методов JavaScript? Например, функция fetch. А можете рассказать, как работает fetch? Мы, собственно говоря, в фетч помещаем какую-либо ссылку, например, на сторонний веб-ресурс и, собственно говоря, вызываем в коде фетч. Фетч возвращает промисс, к которой мы можем дождаться и, собственно говоря, получить результат и что-то с ним сделать. Что будет, когда промисс резолвится? Что вернет фетч? Фетч вернет, собственно говоря, респонс какой-то с данными, которым можно в дальнейшем А что значит «респонс»? Что будет в этом «респонсе»? Объект… Объект «респонса» будет, получается, и дальше мы можем JSON преобразовать, вызвать метод JSON у него. А объект «респонс» — что там внутри будет? Какие поля там будут? Статус данной, дата, например, статус запроса, успешен, неуспешен. Хорошо, а после этого нам данные получить как? Ну, сделать функцию JSON над респонсом, взять респонс и точка JSON и, собственно говоря, так получить данные, например. Хорошо, а если у нас данные сервера приходят не в формате JSON, а в другом формате? Ну, использовать там дата, property дата будет в результате.  То есть если JSON, нам нужно какой-то метод использовать дополнительный, а если не JSON, то просто берем пропорт цитаты из оригинального респонса. Поняла Вас, спасибо. Давайте перейдем к вопросам по React. Первый вопрос тоже общего характера. Что такое React фрагмент и зачем он нужен обычно в React? React фрагмент — это элемент в React,  в реакте, которым мы можем оборачивать какие-либо компоненты в реакте. Так как у нас в реакте может быть одна корневая домнода, соответственно, мы можем оборачивать эти элементы в реакте, если нам нужно. И, собственно говоря, они никак в верстке не появляются. Мы не дивом оборачиваем, а как бы фрагментом, который в домноде никак не отображается. Да, отлично, всё так и есть, спасибо. Мой второй вопрос такой. Можете кратко описать, как работает кук UseEffect в реакции?  примаунти компонента. Если мы из него что-то возвращаем, например, функцию возвращаем, то это эмуляция размонтирования компонента. UseEffect будет вызываться... Мы можем в UseEffect в скобочке и в авторе property определять какие-то переменные, при изменении которых будет этот UseEffect запускаться. Что значит в скобочке? Что такое в скобочке?  когда мы вызываем юзуффект, там получается два у него аргумента. Он принимает первым аргументом callback, а вторым аргументом получается массив зависимости, изменение которых, собственно говоря, он будет вызываться. Ретурн сделать из юзуффекта. И, соответственно, он должен быть с пустыми,  он должен быть с пустыми скобками. Что такое с пустыми скобками? Ну, то есть мы второй аргумент, вот этот зависимости, массив зависимости делаем пустым и возвращаем какой-либо... То есть всегда у нас массив зависимости должен быть обязательно пустым? Нет, не всегда. То, что мы хотим эмулировать, соответственно, этот метод жизненного цикла, когда размонтируется компонент, мы делаем пустыми скобками. Так, хорошо. А если у нас А если у нас есть функция return? То есть у нас useEffect возвращает какую-то функцию, но при этом у нас массив зависимости не пустой, там есть какие-то переменные. Да, он будет вызываться каждый раз при вызове useEffect. Что будет вызываться каждый раз? Ну, вот этот return. А вот, например, у нас есть в useEffect функция, например, setTimeout.  В return мы возвращаем функцию clearTimeout, то есть даем интервал какой-то и его очищаем. Но при этом у нас массив зависимости не пустой. То каким образом эти функции работают? Так, массив зависимости еще раз не пустой? Да. Так, setTimeout. По сути, у нас будет создаваться тайм-аут, и он будет убираться при размонтировании этого компонента. Каким образом работают эти функции?  Соответственно, он там первый раз... У нас переменная изменилась, и эффект у нас должен сработать. У нас как раз она изменилась. Да, запускается setTimeout, и потом он, получается, очищается. То есть таймаута нет в итоге, да? Ну да. Поняла вас, спасибо. Смотрите, следующий вопрос связан с формами. У нас на проектах банковских приложений часто используются формы. Ну, достаточно часто.  Поэтому вопрос такой. В реакции есть управляемые и неуправляемые инпуты. Может быть, сталкивались с этим. Чем они друг от друга отличаются? Когда что лучше использовать? Собственно, управляемые — это когда мы присваиваем какие-либо значения, то есть мы привязываем инпуты, и он зависит от каких-то переменных, например. Неуправляемые — получается, что мы не завязываем на какие-то значения NGS-овские инпуты. И неуправляемо в основном используется, когда нужно оптимизировать, например, работу большой сложной формы, когда у нас множество перерисовок и множество изменений, собственно говоря, этих переменных, которые связаны. И, например, библиотека React Hook Forms, она как раз-таки работает на вот как раз несвязанных инпутах. А связанный, собственно, когда мы прям хотим жесткий контроль над значениями. И когда нам, например, нужно изменять… То есть мы хотим, например, при изменении каких-либо переменных перерисовывать значения в input. Просто при неуправляемых там немножко другой механизм того, как меняются значения. Мы используем татарьев, привязываем элементы и меняем маневры. Отлично. Спасибо большое. Последний вопрос будет такой. Какие методы оптимизации веб-приложений вы знаете, сталкивались в практике? Веб-приложения... Например, кэширование. Смотря что имеется в виду под оптимизацией, если, например, имеется в виду скорость загрузки первой страницы и также количество ресурсов, которые пользователь грузит себе на компьютер, когда заходит на нашу страницу. Как раз, например, кэширование. Для React, например, актуально lazy loading. Мы можем загружать страницу, когда она только используется, когда мы на нее переходим, например. Каким образом это работает?  Ну, React первоначально эту страницу никак не загружает. Когда, собственно говоря, мы переходим на эту страницу, React.js, собственно говоря, определяет, что мы на ней. А что значит, что конкретно происходит, что конкретно React делает? Ну, проверяет, что мы по URL-странице, проверяет, что мы на ней или нет, и, соответственно, грузит ее или нет. Там есть так называемый саспент, можно компонент использовать, который, собственно говоря,  Да, отлично. Но, соответственно, там есть проблема, что его нужно как бы актуализировать, потому что данные могут поменяться, а кэш будет старый. То есть надо следить за тем, чтобы он был актуальный кэш. А как за этим следить? Ну, ставятся различного рода параметры, допустим, на том же Nginx, чтобы инвалидировался кэш. Так, подождите, Александр, мы про фронтенд говорим. Мы с вами на фронтенд. Да, я понял. Ну, так, давайте про фронтенд. Если мы используем какой-нибудь TansTagQuery для запросов, который кэширует запросы, например, мы... То что, простите, что? Ну, есть библиотека TansTagQuery для запросов. Какая, какая? Еще раз. Ну, ReactQuery она еще называется. ReactQuery, TansTagQuery. А, ReactQuery, ReactQuery, мы знаем, да. Хорошо. Вот, в ней, например... А, TansTagQuery вы имеете в виду, да? Да, в ней, например, есть параметр invalidate. Мы можем указывать, через сколько кэш, например, будет. как, например, будут устаревшие. Так, хорошо, кэширование запросов, да, согласна с Вами. С точки зрения фронта…так, оптимизация…Мы можем использовать современные форматы, например, изображений и современные форматы шрифтов, например, которые оптимизированы. То же самое с видео. Что еще мы на фронтенде? Мы можем сборку оптимизировать, чтобы чанки оптимизировать, сборки, чтобы они поменьше их сделали, чтобы они быстрее грузились. А что значит поменьше их делать, чтобы они быстрее грузились? Сборщики можно настроить размеры чанков и, соответственно, при манипулировании этим размером чанков, то есть он на определенной части делит JS-код, Кроме того, у нас, например, вся сборка JavaScript-кода весит 2 Мбайта. Вы разделили это на два чанка по 1 Мбайту. Каким образом два чанка по 1 Мбайту загрузятся быстрее, чем один чанк на 2 Мбайта? Вопрос — загрузится ли это быстрее? Основное, да. Если из такого еще, например, можно... Ну, это уже не относится к фронту сжатия, например, G-Zip или любое другое сжатие на том же Nginx. Ну, обычно Nginx там делается. Зачем на фронтенде тоже сжимать сборщиками? Зачем на фронтенде сборщиками? Это очень редкое использование, в основном на том же Nginx. Зачем? Если это, например, тот же самый, так как это HTML, когда мы сжимаем, соответственно, у нас уменьшается размер файла. Нет, я понимаю, как работает компрессия, я понимаю. Просто зачем на фронтенде это делать, если обычно это делается на фронте?  На фронте это редко используется. Обычно на Nginx делается, то есть на сервере делается. На Nginx, видите, мы заканчиваем, потому что у нас собеседование по фронтензии все-таки. Спасибо большое. Спасибо. Основные способы вы перечислили. Смотрите, у меня больше вопросов не осталось. Тогда я предлагаю вам рассказать о проекте и ответить на ваши вопросы. Хорошо? Хорошо. Хотелось бы узнать, что за проект, что там еще используется. Вот, сам он про проект больше.  Да, конечно. Сейчас как раз я вам все расскажу. И если какие-то будут вопросы по работе проекта, то задавайте. Постараюсь ответить на то, что я знаю. Итак, проект, на который сейчас идет набор фонтен-разработчиков, называется «Интернет-банк для юридических лиц». Я думаю, что вы знакомы с приложением «Интернет-банк для физических лиц». В принципе, «Интернет-банк для юридических лиц» похож по функциональности.  Не только он отличается по функционалу, но в целом похоже это приложение на интернет-банк для физических лиц. Это приложение уже на проде около полутора лет. Сейчас идет активная разработка страниц приложения. Также у нас, например, часто обновляются требования от Центробанка и необходимо править уже существующий функционал.  разрабатывать страницы приложений, которые еще не успели вывести на прот. То есть в основном работа будет идти вот в таком ключе. Постэк у технологий это React TypeScript и также микрофронты. То есть то, что вы как раз рассказывали о предыдущих проектах. Сам проект, он достаточно объемный, поэтому работа над ним разбита между командами. Всего над проектом занято шесть команд, и эти шесть команд, они разбиты,  шесть команд разбили функционально. То есть есть команда, которая занимается кредитами, есть команда, которая занимается картами и так далее. То есть каждая команда работает на своей небольшой функциональности. Состав команд одинаковый. Это руководитель проекта, веб-разработчик, это реактор-разработчик в нашем случае, мобильные разработчики, бэкэнд-разработчик, аналитик, тестировщик и дизайнер. Соответственно, вы работаете в своей маленькой команде,  но также все равно, так как вы работаете над одним приложением, то вы будете пересекаться с другими командами, и также у этих команд есть фронтовый темлит и бэкэнд темлит. Соответственно, задача уже темлитов — это непосредственно разработка архитектуры приложения, в целом настройка приложения, то есть какие-то такие основные, основополагающие вещи по архитектуре в основном. А задача уже разработчиков — это доработка,  это доработка функциональности. Так, наверное, это такая основная информация по проекту. Может быть, у вас есть какие-то вопросы? Так, проект вообще, ну, получается, на долгое время или нет в целом по времени? Ну, проект... Ну, каких-то прям... Ну, то есть, предполагается, что разработчики сейчас, они закончат разработку в целом,  разработку в целом проекта, а затем нужно будет его поддерживать, так как у нас постоянно есть какие-то новые требования от Центробанка, новые потребности от бизнеса, поэтому, ну, да, такой проект долгосрочный. А бэкэнд, получается, там, на чем он вообще? Смотрите, бэкэнд у нас на C-Sharp, но у нас фронт-энд разработчики, они вообще не имеют отношения к бэкэнду. Ну, так вроде бы по вопросам, вроде бы и всё.Отлично. Тогда, если у Вас появятся вопросы, Вы можете их задать через Артёма в дальнейшем. Спасибо Вам большое. Хорошего Вам дня. До свидания.Хорошо, спасибо. Всё, спасибо."